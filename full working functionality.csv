"schema_name","function_name","function_definition"
"public","add_trader_to_market_participants","CREATE OR REPLACE FUNCTION public.add_trader_to_market_participants()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_is_private BOOLEAN;
BEGIN
  -- Check if this is a private market
  SELECT is_private INTO v_is_private
  FROM markets
  WHERE id = NEW.market_id;
  
  -- Only add participants for private markets
  IF v_is_private = TRUE THEN
    INSERT INTO market_participants (market_id, user_id, role, created_at)
    VALUES (NEW.market_id, NEW.user_id, 'participant', NOW())
    ON CONFLICT ON CONSTRAINT market_participants_market_user_unique DO NOTHING;
  END IF;
  
  RETURN NEW;
END;
$function$
"
"public","armor","CREATE OR REPLACE FUNCTION public.armor(bytea)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_armor$function$
"
"public","armor","CREATE OR REPLACE FUNCTION public.armor(bytea, text[], text[])
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_armor$function$
"
"public","audit_ledger_balance","CREATE OR REPLACE FUNCTION public.audit_ledger_balance()
 RETURNS TABLE(transaction_group_id uuid, net_amount_cents bigint, is_balanced boolean)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    le.transaction_group_id,
    SUM(CASE WHEN le.entry_side = 'credit' THEN le.amount_cents 
             WHEN le.entry_side = 'debit' THEN -le.amount_cents
             ELSE 0 END) as net_amount_cents,
    SUM(CASE WHEN le.entry_side = 'credit' THEN le.amount_cents 
             WHEN le.entry_side = 'debit' THEN -le.amount_cents
             ELSE 0 END) = 0 as is_balanced
  FROM ledger_entries le
  WHERE le.transaction_group_id IS NOT NULL
  GROUP BY le.transaction_group_id
  HAVING SUM(CASE WHEN le.entry_side = 'credit' THEN le.amount_cents 
                  WHEN le.entry_side = 'debit' THEN -le.amount_cents
                  ELSE 0 END) != 0;
END;
$function$
"
"public","calculate_market_state_audit","CREATE OR REPLACE FUNCTION public.calculate_market_state_audit()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_prev_lp DECIMAL(10,2) := 0;
    v_prev_qy DECIMAL(10,2) := 0;
    v_prev_qn DECIMAL(10,2) := 0;
    v_lp_debit DECIMAL(10,2) := 0;
    v_lp_credit DECIMAL(10,2) := 0;
    v_qy_debit DECIMAL(10,2) := 0;
    v_qy_credit DECIMAL(10,2) := 0;
    v_qn_debit DECIMAL(10,2) := 0;
    v_qn_credit DECIMAL(10,2) := 0;
    v_current_lp DECIMAL(10,2);
    v_current_qy DECIMAL(10,2);
    v_current_qn DECIMAL(10,2);
BEGIN
    -- Acquire advisory lock per market to prevent race conditions
    PERFORM pg_advisory_xact_lock(hashtext(NEW.market_id::text));

    -- Get current market state directly from markets table (source of truth)
    SELECT 
        COALESCE(liquidity_pool, 0),
        COALESCE(qy, 0),
        COALESCE(qn, 0)
    INTO v_current_lp, v_current_qy, v_current_qn
    FROM markets
    WHERE id = NEW.market_id;

    -- Get the previous transaction state for calculating deltas
    SELECT 
        COALESCE(market_liquidity_pool, 0),
        COALESCE(market_qy, 0),
        COALESCE(market_qn, 0)
    INTO v_prev_lp, v_prev_qy, v_prev_qn
    FROM transactions
    WHERE market_id = NEW.market_id
      AND created_at < NEW.created_at
    ORDER BY created_at DESC, id DESC
    LIMIT 1;

    -- If no previous transaction, use zeros
    v_prev_lp := COALESCE(v_prev_lp, 0);
    v_prev_qy := COALESCE(v_prev_qy, 0);
    v_prev_qn := COALESCE(v_prev_qn, 0);

    -- Calculate debits/credits based on actual market state changes
    -- Calculate what changed between previous state and current market state
    v_lp_credit := GREATEST(v_current_lp - v_prev_lp, 0);
    v_lp_debit := GREATEST(v_prev_lp - v_current_lp, 0);
    v_qy_credit := GREATEST(v_current_qy - v_prev_qy, 0);
    v_qy_debit := GREATEST(v_prev_qy - v_current_qy, 0);
    v_qn_credit := GREATEST(v_current_qn - v_prev_qn, 0);
    v_qn_debit := GREATEST(v_prev_qn - v_current_qn, 0);

    -- Update the NEW row with calculated values
    NEW.lp_debit := v_lp_debit;
    NEW.lp_credit := v_lp_credit;
    NEW.qy_debit := v_qy_debit;
    NEW.qy_credit := v_qy_credit;
    NEW.qn_debit := v_qn_debit;
    NEW.qn_credit := v_qn_credit;

    -- Store current market state (not calculated state)
    -- This ensures transactions table always reflects actual market state at that moment
    NEW.market_liquidity_pool := v_current_lp;
    NEW.market_qy := v_current_qy;
    NEW.market_qn := v_current_qn;

    RETURN NEW;
END;
$function$
"
"public","calculate_yes_probability","CREATE OR REPLACE FUNCTION public.calculate_yes_probability(p_qy numeric, p_qn numeric, p_b numeric)
 RETURNS numeric
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
DECLARE
    v_exp_qy NUMERIC;
    v_exp_qn NUMERIC;
BEGIN
    -- LMSR probability formula: P(yes) = e^(qy/b) / (e^(qy/b) + e^(qn/b))
    v_exp_qy := EXP(p_qy / p_b);
    v_exp_qn := EXP(p_qn / p_b);
    RETURN ROUND((v_exp_qy / (v_exp_qy + v_exp_qn)) * 100, 2);
END;
$function$
"
"public","can_settle_via_uma","CREATE OR REPLACE FUNCTION public.can_settle_via_uma(market_id_param uuid)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
  market_record RECORD;
  pending_proposals INTEGER;
BEGIN
  SELECT * INTO market_record FROM markets WHERE id = market_id_param;
  
  IF NOT FOUND THEN
    RETURN FALSE;
  END IF;
  
  -- Must be a public market
  IF market_record.is_private THEN
    RETURN FALSE;
  END IF;
  
  -- Must be deployed to blockchain
  IF market_record.blockchain_status = 'not_deployed' THEN
    RETURN FALSE;
  END IF;
  
  -- Check if liveness period has expired
  IF market_record.uma_liveness_ends_at IS NOT NULL 
     AND market_record.uma_liveness_ends_at <= NOW() 
     AND market_record.blockchain_status = 'proposal_pending' THEN
    RETURN TRUE;
  END IF;
  
  RETURN FALSE;
END;
$function$
"
"public","cancel_market","CREATE OR REPLACE FUNCTION public.cancel_market(p_market_id uuid, p_admin_user_id uuid)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  market_record RECORD;
  position_record RECORD;
  user_net_investment NUMERIC;
  total_refunds NUMERIC := 0;
  users_refunded INTEGER := 0;
  remaining_liquidity NUMERIC := 0;
  initial_liquidity NUMERIC := 0;
  liquidity_return_amount NUMERIC := 0;
  result JSON;
BEGIN
  SELECT * INTO market_record FROM markets WHERE id = p_market_id FOR UPDATE;
  
  IF NOT FOUND THEN
    RETURN json_build_object('success', false, 'error', 'Market not found');
  END IF;
  
  IF market_record.outcome IS NOT NULL OR market_record.status = 'settled' OR market_record.status = 'cancelled' THEN
    RETURN json_build_object('success', false, 'error', 'Market already settled or cancelled');
  END IF;

  FOR position_record IN 
    SELECT p.*, pr.username, pr.display_name
    FROM positions p
    JOIN profiles pr ON p.user_id = pr.id
    WHERE p.market_id = p_market_id 
    AND p.shares > 0.0001
  LOOP
    user_net_investment := position_record.amount_invested;
    
    IF user_net_investment > 0.01 THEN
      UPDATE profiles 
      SET balance = balance + user_net_investment
      WHERE id = position_record.user_id;
      
      INSERT INTO transactions (
        user_id, market_id, type, amount, shares, price_per_share, 
        cost_basis, realized_pnl, side, description
      )
      VALUES (
        position_record.user_id, p_market_id, 'sell',
        user_net_investment, position_record.shares, position_record.avg_price,
        user_net_investment, 0, position_record.side,
        'Market cancelled - refund at cost basis'
      );
      
      INSERT INTO notifications (user_id, market_id, type, title, message, is_read)
      VALUES (
        position_record.user_id, p_market_id, 'market_cancelled',
        'Market Cancelled - Refund Issued',
        'The market has been cancelled. You have been refunded $' || ROUND(user_net_investment, 2)::TEXT,
        false
      );
      
      total_refunds := total_refunds + user_net_investment;
      users_refunded := users_refunded + 1;
    END IF;
    
    DELETE FROM positions 
    WHERE user_id = position_record.user_id 
    AND market_id = p_market_id;
  END LOOP;

  UPDATE markets 
  SET 
    liquidity_pool = GREATEST(0, liquidity_pool - total_refunds),
    yes_shares = 0,
    no_shares = 0
  WHERE id = p_market_id
  RETURNING liquidity_pool INTO remaining_liquidity;
  
  IF market_record.b IS NOT NULL AND market_record.b > 0 THEN
    initial_liquidity := (market_record.b + 1) * LN(2);
    
    IF remaining_liquidity > 0 THEN
      liquidity_return_amount := LEAST(remaining_liquidity, initial_liquidity);
      
      UPDATE profiles 
      SET balance = balance + liquidity_return_amount
      WHERE id = market_record.creator_id;
      
      INSERT INTO transactions (user_id, market_id, type, amount, description)
      VALUES (
        market_record.creator_id, p_market_id, 'liquidity_return',
        liquidity_return_amount, 'Initial liquidity return from cancelled market'
      );
      
      UPDATE markets 
      SET liquidity_pool = liquidity_pool - liquidity_return_amount
      WHERE id = p_market_id;
    END IF;
  END IF;

  UPDATE markets 
  SET 
    status = 'cancelled',
    outcome = NULL,
    winning_side = NULL,
    settled_by = p_admin_user_id,
    settled_at = NOW()
  WHERE id = p_market_id;

  INSERT INTO notifications (user_id, market_id, type, title, message, is_read)
  VALUES (
    market_record.creator_id, p_market_id, 'market_cancelled',
    'Market Cancelled',
    'Your market has been cancelled. Total refunds: $' || ROUND(total_refunds, 2)::TEXT || 
    '. Liquidity returned: $' || ROUND(COALESCE(liquidity_return_amount, 0), 2)::TEXT,
    false
  );

  result := json_build_object(
    'success', true,
    'total_refunds', total_refunds,
    'users_refunded', users_refunded,
    'liquidity_returned', liquidity_return_amount
  );

  RETURN result;
END;
$function$
"
"public","check_all_balance_reconciliation","CREATE OR REPLACE FUNCTION public.check_all_balance_reconciliation()
 RETURNS TABLE(user_id uuid, username text, profile_balance numeric, ledger_balance numeric, difference numeric)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    p.id as user_id,
    p.username,
    p.balance as profile_balance,
    -- Removed account_type filter since ledger_entries table doesn't have that column
    COALESCE(SUM(l.credit - l.debit), 0) as ledger_balance,
    p.balance - COALESCE(SUM(l.credit - l.debit), 0) as difference
  FROM profiles p
  LEFT JOIN ledger_entries l ON l.user_id = p.id
  GROUP BY p.id, p.username, p.balance
  HAVING ABS(p.balance - COALESCE(SUM(l.credit - l.debit), 0)) > 0.01; -- Flag differences > 1 cent
END;
$function$
"
"public","check_pending_settlements","CREATE OR REPLACE FUNCTION public.check_pending_settlements()
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_result JSON;
BEGIN
    -- Return markets categorized by settlement_status
    SELECT json_build_object(
        'pending_contest', COALESCE(
            (SELECT json_agg(market_data)
             FROM (
                 SELECT 
                     m.id as market_id,
                     m.title,
                     m.status,
                     m.settlement_status,
                     m.contest_deadline,
                     m.creator_settlement_outcome,
                     (SELECT COUNT(*) FROM settlement_bonds WHERE market_id = m.id) as proposal_bonds,
                     (SELECT COUNT(*) FROM settlement_contests WHERE market_id = m.id) as contest_bonds,
                     (SELECT COUNT(*) 
                      FROM settlement_votes sv 
                      JOIN settlement_contests sc ON sv.contest_id = sc.id 
                      WHERE sc.market_id = m.id) as vote_bonds,
                     (SELECT COALESCE(SUM(bond_amount), 0) FROM settlement_bonds WHERE market_id = m.id) as total_proposal_amount,
                     (SELECT COALESCE(SUM(contest_bond_amount), 0) FROM settlement_contests WHERE market_id = m.id) as total_contest_amount,
                     (SELECT COALESCE(SUM(sv.vote_bond_amount), 0)
                      FROM settlement_votes sv 
                      JOIN settlement_contests sc ON sv.contest_id = sc.id 
                      WHERE sc.market_id = m.id) as total_vote_amount
                 FROM markets m
                 WHERE m.is_private = true 
                   AND m.settlement_status = 'pending_contest'
                 ORDER BY m.contest_deadline ASC
             ) market_data),
            '[]'::json
        ),
        'contested', COALESCE(
            (SELECT json_agg(market_data)
             FROM (
                 SELECT 
                     m.id as market_id,
                     m.title,
                     m.status,
                     m.settlement_status,
                     m.contest_deadline,
                     m.creator_settlement_outcome,
                     (SELECT COUNT(*) FROM settlement_bonds WHERE market_id = m.id) as proposal_bonds,
                     (SELECT COUNT(*) FROM settlement_contests WHERE market_id = m.id) as contest_bonds,
                     (SELECT COUNT(*) 
                      FROM settlement_votes sv 
                      JOIN settlement_contests sc ON sv.contest_id = sc.id 
                      WHERE sc.market_id = m.id) as vote_bonds,
                     (SELECT COALESCE(SUM(bond_amount), 0) FROM settlement_bonds WHERE market_id = m.id) as total_proposal_amount,
                     (SELECT COALESCE(SUM(contest_bond_amount), 0) FROM settlement_contests WHERE market_id = m.id) as total_contest_amount,
                     (SELECT COALESCE(SUM(sv.vote_bond_amount), 0)
                      FROM settlement_votes sv 
                      JOIN settlement_contests sc ON sv.contest_id = sc.id 
                      WHERE sc.market_id = m.id) as total_vote_amount
                 FROM markets m
                 WHERE m.is_private = true 
                   AND m.settlement_status = 'contested'
                 ORDER BY m.contest_deadline ASC
             ) market_data),
            '[]'::json
        ),
        'voting', COALESCE(
            (SELECT json_agg(market_data)
             FROM (
                 SELECT 
                     m.id as market_id,
                     m.title,
                     m.status,
                     m.settlement_status,
                     m.contest_deadline,
                     m.creator_settlement_outcome,
                     (SELECT COUNT(*) FROM settlement_bonds WHERE market_id = m.id) as proposal_bonds,
                     (SELECT COUNT(*) FROM settlement_contests WHERE market_id = m.id) as contest_bonds,
                     (SELECT COUNT(*) 
                      FROM settlement_votes sv 
                      JOIN settlement_contests sc ON sv.contest_id = sc.id 
                      WHERE sc.market_id = m.id) as vote_bonds,
                     (SELECT COALESCE(SUM(bond_amount), 0) FROM settlement_bonds WHERE market_id = m.id) as total_proposal_amount,
                     (SELECT COALESCE(SUM(contest_bond_amount), 0) FROM settlement_contests WHERE market_id = m.id) as total_contest_amount,
                     (SELECT COALESCE(SUM(sv.vote_bond_amount), 0)
                      FROM settlement_votes sv 
                      JOIN settlement_contests sc ON sv.contest_id = sc.id 
                      WHERE sc.market_id = m.id) as total_vote_amount
                 FROM markets m
                 WHERE m.is_private = true 
                   AND m.settlement_status = 'voting'
                 ORDER BY m.contest_deadline ASC
             ) market_data),
            '[]'::json
        )
    ) INTO v_result;
    
    RETURN v_result;
END;
$function$
"
"public","contest_settlement","CREATE OR REPLACE FUNCTION public.contest_settlement(p_market_id uuid, p_contestant_id uuid)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_market_record RECORD;
  v_settlement_bond RECORD;
  v_contest_bond_amount DECIMAL(10,2) := 50.00;
  v_vote_deadline TIMESTAMP;
  v_total_participants INT;
  v_selected_verifiers INT;
  v_verifier_ids UUID[];
  v_contestant_balance DECIMAL(10,2);
  v_contest_id UUID;
  v_market_title TEXT;
  v_contestant_name TEXT;
BEGIN
  -- Lock the market row to prevent race conditions
  SELECT m.*, sb.outcome_chosen as creator_outcome, m.title
  INTO v_market_record
  FROM markets m
  JOIN settlement_bonds sb ON sb.market_id = m.id
  WHERE m.id = p_market_id
  AND m.settlement_status = 'pending_contest'
  AND m.contest_deadline > NOW()
  FOR UPDATE OF m;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Market not found, not in contest period, or contest period expired';
  END IF;
  
  v_market_title := v_market_record.title;

  -- Verify contestant is a participant
  IF NOT EXISTS (
    SELECT 1 FROM transactions 
    WHERE market_id = p_market_id 
    AND user_id = p_contestant_id
  ) THEN
    RAISE EXCEPTION 'You must be a market participant to contest';
  END IF;

  -- Check if already contested
  IF EXISTS (
    SELECT 1 FROM settlement_contests 
    WHERE market_id = p_market_id
  ) THEN
    RAISE EXCEPTION 'Settlement has already been contested by another participant';
  END IF;

  -- Check contestant balance
  SELECT balance INTO v_contestant_balance FROM profiles WHERE id = p_contestant_id;

  IF v_contestant_balance < v_contest_bond_amount THEN
    RAISE EXCEPTION 'Insufficient balance for contest bond ($50 required)';
  END IF;

  -- Deduct contest bond
  UPDATE profiles
  SET balance = balance - v_contest_bond_amount
  WHERE id = p_contestant_id;

  -- Set vote deadline (1 hour from now)
  v_vote_deadline := NOW() + INTERVAL '1 hour';

  -- Create contest record
  INSERT INTO settlement_contests (
    market_id,
    contestant_id,
    contest_bond_amount,
    created_at,
    vote_deadline,
    status
  ) VALUES (
    p_market_id,
    p_contestant_id,
    v_contest_bond_amount,
    NOW(),
    v_vote_deadline,
    'voting'
  )
  RETURNING id INTO v_contest_id;

  -- Update market status
  UPDATE markets
  SET 
    settlement_status = 'contested',
    status = 'contested'
  WHERE id = p_market_id;

  -- Notify the creator that their settlement was contested
  INSERT INTO notifications (
    user_id,
    type,
    title,
    message,
    market_id,
    created_at,
    is_read
  ) VALUES (
    v_market_record.creator_id,
    'settlement_contested',
    'Your Settlement Was Contested',
    'A participant has contested your proposed settlement for ""' || v_market_title || 
    '"". Voting is now in progress and will end at ' || TO_CHAR(v_vote_deadline, 'Mon DD at HH:MI AM') || '.',
    p_market_id,
    NOW(),
    false
  );

  -- Count total participants (excluding creator and contestant)
  SELECT COUNT(DISTINCT user_id) INTO v_total_participants
  FROM transactions
  WHERE market_id = p_market_id
  AND user_id NOT IN (v_market_record.creator_id, p_contestant_id);

  -- Select verifiers (all if ≤5, random ≥30% if >5)
  IF v_total_participants <= 5 THEN
    SELECT ARRAY_AGG(DISTINCT user_id) INTO v_verifier_ids
    FROM transactions
    WHERE market_id = p_market_id
    AND user_id NOT IN (v_market_record.creator_id, p_contestant_id);
  ELSE
    v_selected_verifiers := GREATEST(CEIL(v_total_participants * 0.3), 1);
    
    SELECT ARRAY_AGG(user_id) INTO v_verifier_ids
    FROM (
      SELECT DISTINCT user_id
      FROM transactions
      WHERE market_id = p_market_id
      AND user_id NOT IN (v_market_record.creator_id, p_contestant_id)
      ORDER BY RANDOM()
      LIMIT v_selected_verifiers
    ) selected;
  END IF;

  -- Create notifications for selected verifiers
  INSERT INTO notifications (user_id, type, title, message, market_id, created_at, is_read)
  SELECT 
    unnest(v_verifier_ids),
    'vote_requested',
    'Settlement Contested - Vote Required',
    'A settlement for ""' || v_market_title || '"" has been contested. You have been selected to vote. ' ||
    'Post a $25 bond to vote by ' || TO_CHAR(v_vote_deadline, 'Mon DD at HH:MI AM') || '.',
    p_market_id,
    NOW(),
    false;

  RETURN json_build_object(
    'success', true,
    'contest_id', v_contest_id,
    'vote_deadline', v_vote_deadline,
    'verifiers_notified', COALESCE(array_length(v_verifier_ids, 1), 0)
  );
END;
$function$
"
"public","contest_settlement_v2","CREATE OR REPLACE FUNCTION public.contest_settlement_v2(p_market_id uuid, p_contestant_id uuid, p_contested_outcome text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_market_record RECORD;
  v_bond_amount NUMERIC;
  v_contest_id UUID;
  v_vote_deadline TIMESTAMPTZ;
  v_contestant_balance NUMERIC;
  v_voters_to_notify INTEGER := 5;
  v_voter_record RECORD;
BEGIN
  -- Get market details
  SELECT * INTO v_market_record
  FROM markets
  WHERE id = p_market_id;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Market not found');
  END IF;
  
  -- Check market is in pending_contest status
  IF v_market_record.settlement_status != 'pending_contest' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Market is not in pending_contest status. Current status: ' || COALESCE(v_market_record.settlement_status, 'null'));
  END IF;
  
  -- Check contestant is not the creator
  IF p_contestant_id = v_market_record.creator_id THEN
    RETURN jsonb_build_object('success', false, 'error', 'Market creator cannot contest their own settlement');
  END IF;
  
  -- Check contestant has a position in this market
  IF NOT EXISTS (
    SELECT 1 FROM positions 
    WHERE market_id = p_market_id 
    AND user_id = p_contestant_id
    AND shares > 0
  ) THEN
    RETURN jsonb_build_object('success', false, 'error', 'You must have a position in this market to contest');
  END IF;
  
  -- Fixed contest bond amount to $50
  v_bond_amount := 50.00;
  
  -- Check contestant has sufficient balance
  SELECT balance INTO v_contestant_balance
  FROM profiles
  WHERE id = p_contestant_id;
  
  IF v_contestant_balance IS NULL OR v_contestant_balance < v_bond_amount THEN
    RETURN jsonb_build_object('success', false, 'error', 'Insufficient balance for contest bond. Required: $' || v_bond_amount);
  END IF;
  
  -- Deduct bond from contestant's balance
  UPDATE profiles
  SET balance = balance - v_bond_amount
  WHERE id = p_contestant_id;
  
  -- Set vote deadline (1 hour from now)
  v_vote_deadline := NOW() + INTERVAL '1 hour';
  
  -- Insert contest record
  INSERT INTO settlement_contests (
    market_id,
    contestant_id,
    contested_outcome_text,
    contest_bond_amount,
    vote_deadline,
    status
  ) VALUES (
    p_market_id,
    p_contestant_id,
    p_contested_outcome,
    v_bond_amount,
    v_vote_deadline,
    'active'
  )
  RETURNING id INTO v_contest_id;
  
  -- Update market status
  UPDATE markets
  SET 
    settlement_status = 'contested',
    contest_deadline = v_vote_deadline,
    updated_at = NOW()
  WHERE id = p_market_id;
  
  -- Removed 'read' column from all INSERT INTO notifications - column doesn't exist
  -- Create notification for market creator
  INSERT INTO notifications (
    user_id,
    type,
    title,
    message,
    market_id
  ) VALUES (
    v_market_record.creator_id,
    'settlement_contested',
    'Settlement Contested',
    'Your proposed settlement for ""' || v_market_record.title || '"" has been contested. Voting will determine the outcome.',
    p_market_id
  );
  
  -- Create notification for contestant
  INSERT INTO notifications (
    user_id,
    type,
    title,
    message,
    market_id
  ) VALUES (
    p_contestant_id,
    'contest_submitted',
    'Contest Submitted',
    'You have contested the settlement for ""' || v_market_record.title || '"". Your bond of $' || v_bond_amount || ' will be returned if your contest succeeds.',
    p_market_id
  );
  
  -- Notify random position holders to vote
  FOR v_voter_record IN 
    SELECT sub.user_id FROM (
      SELECT DISTINCT pos.user_id
      FROM positions pos
      WHERE pos.market_id = p_market_id
      AND pos.user_id != v_market_record.creator_id
      AND pos.user_id != p_contestant_id
      AND pos.shares > 0
    ) AS sub
    ORDER BY RANDOM()
    LIMIT v_voters_to_notify
  LOOP
    INSERT INTO notifications (
      user_id,
      type,
      title,
      message,
      market_id
    ) VALUES (
      v_voter_record.user_id,
      'vote_requested',
      'Vote Requested',
      'A settlement dispute needs your vote for ""' || v_market_record.title || '"". Please cast your vote before the deadline.',
      p_market_id
    );
  END LOOP;
  
  RETURN jsonb_build_object(
    'success', true,
    'contest_id', v_contest_id,
    'bond_amount', v_bond_amount,
    'vote_deadline', v_vote_deadline,
    'message', 'Contest submitted successfully'
  );
  
EXCEPTION WHEN OTHERS THEN
  RETURN jsonb_build_object('success', false, 'error', SQLERRM);
END;
$function$
"
"public","create_ledger_entry","CREATE OR REPLACE FUNCTION public.create_ledger_entry(p_account_id uuid, p_user_id uuid, p_entry_side text, p_amount_cents bigint, p_entry_type text, p_transaction_id uuid DEFAULT NULL::uuid, p_market_id uuid DEFAULT NULL::uuid, p_account_type text DEFAULT NULL::text, p_transaction_group_id uuid DEFAULT NULL::uuid, p_description text DEFAULT NULL::text, p_metadata jsonb DEFAULT '{}'::jsonb)
 RETURNS uuid
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_ledger_entry_id UUID;
    v_current_balance NUMERIC;
    v_new_balance NUMERIC;
    v_amount NUMERIC;
    v_debit_amount NUMERIC;
    v_credit_amount NUMERIC;
BEGIN
    -- Convert cents to decimal amount
    v_amount := p_amount_cents / 100.0;
    
    -- Set debit/credit to satisfy constraint: one must be 0, other must be > 0
    IF p_entry_side = 'debit' THEN
        v_debit_amount := v_amount;
        v_credit_amount := 0::NUMERIC;  -- Explicitly 0
    ELSIF p_entry_side = 'credit' THEN
        v_debit_amount := 0::NUMERIC;  -- Explicitly 0
        v_credit_amount := v_amount;
    ELSE
        RAISE EXCEPTION 'Invalid entry_side: %. Must be debit or credit', p_entry_side;
    END IF;
    
    -- Ensure the non-zero value is actually > 0
    IF v_amount <= 0 THEN
        RAISE EXCEPTION 'Amount must be greater than zero. Got: % cents', p_amount_cents;
    END IF;
    
    RAISE NOTICE '[Ledger] Creating entry: side=%, amount=$%, debit=%, credit=%', 
        p_entry_side, v_amount, v_debit_amount, v_credit_amount;
    
    -- Get current balance from snapshot
    SELECT balance_cents INTO v_current_balance
    FROM ledger_balance_snapshots
    WHERE account_id = p_account_id;
    
    IF v_current_balance IS NULL THEN
        v_current_balance := 0;
    ELSE
        v_current_balance := v_current_balance / 100.0;
    END IF;
    
    -- Calculate new balance (debit decreases, credit increases)
    IF p_entry_side = 'debit' THEN
        v_new_balance := v_current_balance - v_amount;
    ELSE
        v_new_balance := v_current_balance + v_amount;
    END IF;
    
    -- Insert ledger entry with one column = 0, other > 0
    INSERT INTO ledger_entries (
        account_id,
        user_id,
        entry_side,
        amount_cents,
        debit,
        credit,
        balance_after,
        entry_type,
        transaction_id,
        market_id,
        account_type,
        transaction_group_id,
        description,
        metadata,
        created_at
    ) VALUES (
        p_account_id,
        p_user_id,
        p_entry_side,
        p_amount_cents,
        v_debit_amount,
        v_credit_amount,
        v_new_balance,
        p_entry_type,
        p_transaction_id,
        p_market_id,
        p_account_type,
        p_transaction_group_id,
        p_description,
        p_metadata,
        NOW()
    ) RETURNING id INTO v_ledger_entry_id;
    
    -- Update balance snapshot
    UPDATE ledger_balance_snapshots
    SET 
        balance_cents = (v_new_balance * 100)::BIGINT,
        last_ledger_entry_id = v_ledger_entry_id,
        updated_at = NOW()
    WHERE account_id = p_account_id;
    
    RAISE NOTICE '[Ledger] Entry created: % (balance: $% → $%)', 
        v_ledger_entry_id, v_current_balance, v_new_balance;
    
    RETURN v_ledger_entry_id;
END;
$function$
"
"public","create_ledger_entry","CREATE OR REPLACE FUNCTION public.create_ledger_entry(p_account_id uuid, p_entry_side text, p_amount_cents bigint, p_entry_type text, p_transaction_id uuid, p_user_id uuid, p_market_id uuid, p_description text, p_metadata jsonb DEFAULT '{}'::jsonb)
 RETURNS uuid
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_entry_id UUID;
    v_current_balance_cents BIGINT;
    v_new_balance_cents BIGINT;
    v_debit NUMERIC;
    v_credit NUMERIC;
    v_account_type TEXT;
BEGIN
    -- Get current balance from snapshot
    SELECT balance_cents INTO v_current_balance_cents
    FROM ledger_balance_snapshots
    WHERE account_id = p_account_id;
    
    -- If no balance snapshot exists, this is an error
    IF v_current_balance_cents IS NULL THEN
        RAISE EXCEPTION 'No balance snapshot found for account %. This should never happen.', p_account_id;
    END IF;
    
    -- Set debit/credit to satisfy constraint: one must be 0, other must be > 0
    IF p_entry_side = 'debit' THEN
        v_new_balance_cents := v_current_balance_cents - p_amount_cents;
        v_debit := p_amount_cents / 100.0;
        v_credit := 0::NUMERIC;  -- Explicitly 0
    ELSIF p_entry_side = 'credit' THEN
        v_new_balance_cents := v_current_balance_cents + p_amount_cents;
        v_debit := 0::NUMERIC;  -- Explicitly 0
        v_credit := p_amount_cents / 100.0;
    ELSE
        RAISE EXCEPTION 'Invalid entry_side: %. Must be debit or credit', p_entry_side;
    END IF;
    
    -- Ensure the non-zero value is actually > 0
    IF (p_entry_side = 'debit' AND v_debit <= 0) OR (p_entry_side = 'credit' AND v_credit <= 0) THEN
        RAISE EXCEPTION 'Amount must be greater than zero. Got: % cents', p_amount_cents;
    END IF;
    
    -- Get account type for the entry
    SELECT account_type INTO v_account_type
    FROM ledger_accounts
    WHERE id = p_account_id;
    
    -- Insert ledger entry
    INSERT INTO ledger_entries (
        transaction_id,
        user_id,
        debit,
        credit,
        balance_after,
        entry_type,
        market_id,
        description,
        account_id,
        amount_cents,
        entry_side,
        account_type,
        metadata,
        created_at
    ) VALUES (
        p_transaction_id,
        p_user_id,
        v_debit,
        v_credit,
        v_new_balance_cents / 100.0,
        p_entry_type,
        p_market_id,
        p_description,
        p_account_id,
        p_amount_cents,
        p_entry_side,
        v_account_type,
        p_metadata,
        NOW()
    ) RETURNING id INTO v_entry_id;
    
    -- Update balance snapshot
    UPDATE ledger_balance_snapshots
    SET 
        balance_cents = v_new_balance_cents,
        last_ledger_entry_id = v_entry_id,
        updated_at = NOW()
    WHERE account_id = p_account_id;
    
    RETURN v_entry_id;
END;
$function$
"
"public","create_ledger_entry","CREATE OR REPLACE FUNCTION public.create_ledger_entry(p_account_id uuid, p_amount_cents bigint, p_entry_side text, p_entry_type text, p_market_id uuid, p_transaction_group_id uuid, p_metadata jsonb DEFAULT '{}'::jsonb)
 RETURNS uuid
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_account_type text;
  v_entity_id uuid;
  v_user_id uuid;
  v_entry_id uuid;
BEGIN
  -- Get account info to derive user_id
  SELECT account_type, entity_id 
  INTO v_account_type, v_entity_id
  FROM ledger_accounts 
  WHERE id = p_account_id;
  
  -- Derive user_id based on account type
  IF v_account_type = 'user' THEN
    -- For user accounts, entity_id IS the user_id
    v_user_id := v_entity_id;
  ELSE
    -- For market-related accounts (proposal_bond, contest_bond, etc.), 
    -- try to get creator_id from the market
    SELECT creator_id INTO v_user_id 
    FROM markets 
    WHERE id = p_market_id;
    
    -- If still null, use entity_id as fallback
    IF v_user_id IS NULL THEN
      v_user_id := v_entity_id;
    END IF;
  END IF;
  
  -- If we still don't have a user_id, try to get it from settlement_bonds
  IF v_user_id IS NULL THEN
    SELECT creator_id INTO v_user_id
    FROM settlement_bonds
    WHERE market_id = p_market_id
    LIMIT 1;
  END IF;
  
  -- Call the 9-param version with derived user_id
  v_entry_id := create_ledger_entry(
    p_account_id,
    p_entry_side,
    p_amount_cents,
    p_entry_type,
    NULL::uuid,  -- p_transaction_id
    v_user_id,
    p_market_id,
    NULL::text,  -- p_description
    p_metadata
  );
  
  RETURN v_entry_id;
END;
$function$
"
"public","create_shares_ledger_entry","CREATE OR REPLACE FUNCTION public.create_shares_ledger_entry(p_market_id uuid, p_user_id uuid, p_account_type text, p_side boolean, p_entry_type text, p_entry_side text, p_shares numeric, p_transaction_id uuid DEFAULT NULL::uuid, p_description text DEFAULT NULL::text, p_metadata jsonb DEFAULT '{}'::jsonb)
 RETURNS uuid
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_entry_id UUID;
  v_current_balance NUMERIC;
  v_new_balance NUMERIC;
  v_debit NUMERIC := 0;
  v_credit NUMERIC := 0;
BEGIN
  -- Get current balance based on account type
  IF p_account_type = 'user' THEN
    -- User balance comes from positions table
    SELECT COALESCE(shares, 0) INTO v_current_balance
    FROM positions
    WHERE user_id = p_user_id
      AND market_id = p_market_id
      AND side = p_side;
    
    IF v_current_balance IS NULL THEN
      v_current_balance := 0;
    END IF;
  ELSE
    -- Market balance comes from markets table (qy/qn)
    IF p_side THEN  -- YES side
      SELECT COALESCE(qy, 0) INTO v_current_balance
      FROM markets WHERE id = p_market_id;
    ELSE  -- NO side
      SELECT COALESCE(qn, 0) INTO v_current_balance
      FROM markets WHERE id = p_market_id;
    END IF;
  END IF;

  -- Set debit/credit and calculate new balance
  IF p_entry_side = 'debit' THEN
    v_debit := p_shares;
    v_credit := 0;
    -- For user: debit = shares removed (sell)
    -- For market: debit = shares added (issued to user on buy)
    IF p_account_type = 'user' THEN
      v_new_balance := v_current_balance - p_shares;
    ELSE
      v_new_balance := v_current_balance + p_shares;  -- Market debit increases outstanding
    END IF;
  ELSIF p_entry_side = 'credit' THEN
    v_debit := 0;
    v_credit := p_shares;
    -- For user: credit = shares added (buy)
    -- For market: credit = shares returned (on sell)
    IF p_account_type = 'user' THEN
      v_new_balance := v_current_balance + p_shares;
    ELSE
      v_new_balance := v_current_balance - p_shares;  -- Market credit reduces outstanding
    END IF;
  ELSE
    RAISE EXCEPTION 'Invalid entry_side: %. Must be debit or credit', p_entry_side;
  END IF;

  -- Insert shares ledger entry
  INSERT INTO shares_ledger (
    market_id,
    user_id,
    account_type,
    side,
    entry_type,
    debit,
    credit,
    balance_after,
    transaction_id,
    description,
    metadata
  ) VALUES (
    p_market_id,
    p_user_id,
    p_account_type,
    p_side,
    p_entry_type,
    v_debit,
    v_credit,
    v_new_balance,
    p_transaction_id,
    p_description,
    p_metadata
  )
  RETURNING id INTO v_entry_id;

  RETURN v_entry_id;
END;
$function$
"
"public","create_shares_ledger_entry","CREATE OR REPLACE FUNCTION public.create_shares_ledger_entry(p_market_id uuid, p_user_id uuid, p_account_type text, p_side boolean, p_debit numeric, p_credit numeric, p_entry_type text, p_description text DEFAULT NULL::text, p_metadata jsonb DEFAULT '{}'::jsonb)
 RETURNS uuid
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_entry_id UUID;
  v_current_balance NUMERIC := 0;
  v_balance_after NUMERIC;
BEGIN
  -- Get current balance based on account type
  IF p_account_type = 'user' THEN
    -- User share balance from positions table
    SELECT COALESCE(shares, 0) INTO v_current_balance
    FROM positions
    WHERE user_id = p_user_id AND market_id = p_market_id AND side = p_side;
    
    -- If no position exists, default to 0
    IF v_current_balance IS NULL THEN
      v_current_balance := 0;
    END IF;
  ELSE
    -- Market share balance from markets table (qy/qn)
    IF p_side THEN
      SELECT COALESCE(qy, 0) INTO v_current_balance FROM markets WHERE id = p_market_id;
    ELSE
      SELECT COALESCE(qn, 0) INTO v_current_balance FROM markets WHERE id = p_market_id;
    END IF;
    
    IF v_current_balance IS NULL THEN
      v_current_balance := 0;
    END IF;
  END IF;

  -- Calculate balance after this entry (ensure no NULL)
  v_balance_after := COALESCE(v_current_balance, 0) + COALESCE(p_credit, 0) - COALESCE(p_debit, 0);

  -- Insert ledger entry with CORRECT column order matching table definition:
  -- id, market_id, user_id, account_type, side, debit, credit, balance_after, transaction_id, entry_type, description, metadata, created_at
  INSERT INTO shares_ledger (
    market_id, 
    user_id, 
    account_type, 
    side, 
    debit, 
    credit, 
    balance_after, 
    transaction_id,  -- Will be NULL initially, updated later
    entry_type, 
    description, 
    metadata
  ) VALUES (
    p_market_id, 
    p_user_id, 
    p_account_type, 
    p_side, 
    COALESCE(p_debit, 0), 
    COALESCE(p_credit, 0),
    v_balance_after,
    NULL,  -- transaction_id set later
    p_entry_type, 
    p_description, 
    COALESCE(p_metadata, '{}')
  )
  RETURNING id INTO v_entry_id;

  RETURN v_entry_id;
END;
$function$
"
"public","crypt","CREATE OR REPLACE FUNCTION public.crypt(text, text)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_crypt$function$
"
"public","dearmor","CREATE OR REPLACE FUNCTION public.dearmor(text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_dearmor$function$
"
"public","decrypt","CREATE OR REPLACE FUNCTION public.decrypt(bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_decrypt$function$
"
"public","decrypt_iv","CREATE OR REPLACE FUNCTION public.decrypt_iv(bytea, bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_decrypt_iv$function$
"
"public","digest","CREATE OR REPLACE FUNCTION public.digest(text, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_digest$function$
"
"public","digest","CREATE OR REPLACE FUNCTION public.digest(bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_digest$function$
"
"public","encrypt","CREATE OR REPLACE FUNCTION public.encrypt(bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_encrypt$function$
"
"public","encrypt_iv","CREATE OR REPLACE FUNCTION public.encrypt_iv(bytea, bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_encrypt_iv$function$
"
"public","execute_trade_lmsr","CREATE OR REPLACE FUNCTION public.execute_trade_lmsr(p_market_id uuid, p_user_id uuid, p_bet_amount numeric, p_bet_side character varying, p_qy numeric, p_qn numeric, p_yes_shares numeric, p_no_shares numeric, p_total_volume numeric, p_calculated_shares numeric, p_liquidity_pool numeric)
 RETURNS TABLE(transaction_id uuid, new_balance numeric, new_position_shares numeric)
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_transaction_id UUID;
    v_current_balance NUMERIC(10,2);
    v_new_balance NUMERIC(10,2);
    v_position_id UUID;
    v_current_shares NUMERIC(10,2);
    v_current_invested NUMERIC(10,2);
    v_new_shares NUMERIC(10,2);
    v_new_invested NUMERIC(10,2);
    v_side_boolean BOOLEAN;
    v_fee_amount NUMERIC;
    v_net_amount NUMERIC;
BEGIN
    -- Convert side to boolean for positions table
    v_side_boolean := (p_bet_side = 'yes');
    
    -- Calculate fee (1%) and net amount
    v_fee_amount := p_bet_amount * 0.01;
    v_net_amount := p_bet_amount - v_fee_amount;

    -- Lock and get user's current balance from profiles table
    SELECT balance INTO v_current_balance
    FROM profiles
    WHERE id = p_user_id
    FOR UPDATE;

    -- Check if user has sufficient balance
    IF v_current_balance < p_bet_amount THEN
        RAISE EXCEPTION 'Insufficient balance. Required: %, Available: %', p_bet_amount, v_current_balance;
    END IF;

    -- Deduct the FULL bet amount (including fees) from user balance
    v_new_balance := v_current_balance - p_bet_amount;

    UPDATE profiles
    SET balance = v_new_balance,
        updated_at = now()
    WHERE id = p_user_id;

    -- Update market state
    UPDATE markets
    SET qy = p_qy,
        qn = p_qn,
        total_volume = p_total_volume,
        yes_shares = p_yes_shares,
        no_shares = p_no_shares,
        liquidity_pool = p_liquidity_pool,
        updated_at = now()
    WHERE id = p_market_id;

    -- Create transaction record - trigger will handle ledger automatically
    INSERT INTO transactions (
        id,
        user_id,
        market_id,
        type,
        amount,
        shares,
        price_per_share,
        cost_basis,
        side,
        created_at
    ) VALUES (
        gen_random_uuid(),
        p_user_id,
        p_market_id,
        'buy',
        p_bet_amount::NUMERIC(10,2),
        p_calculated_shares,
        (p_bet_amount / NULLIF(p_calculated_shares, 0)),
        v_net_amount,
        p_bet_side,
        now()
    ) RETURNING id INTO v_transaction_id;

    -- REMOVED manual INSERT INTO ledger_entries - trigger handles this now

    -- Update or create position with side as BOOLEAN
    SELECT id, shares, amount_invested INTO v_position_id, v_current_shares, v_current_invested
    FROM positions
    WHERE user_id = p_user_id 
      AND market_id = p_market_id 
      AND side = v_side_boolean
    FOR UPDATE;

    IF v_position_id IS NOT NULL THEN
        -- Update existing position
        v_new_shares := v_current_shares + p_calculated_shares::NUMERIC(10,2);
        v_new_invested := v_current_invested + v_net_amount::NUMERIC(10,2);

        UPDATE positions
        SET shares = v_new_shares,
            amount_invested = v_new_invested,
            avg_price = (v_new_invested / NULLIF(v_new_shares, 0))::NUMERIC(4,3),
            updated_at = now()
        WHERE id = v_position_id;
    ELSE
        -- Create new position
        v_new_shares := p_calculated_shares::NUMERIC(10,2);
        v_new_invested := v_net_amount::NUMERIC(10,2);

        INSERT INTO positions (
            id,
            user_id,
            market_id,
            side,
            shares,
            amount_invested,
            avg_price,
            created_at,
            updated_at
        ) VALUES (
            gen_random_uuid(),
            p_user_id,
            p_market_id,
            v_side_boolean,
            v_new_shares,
            v_new_invested,
            (v_new_invested / NULLIF(v_new_shares, 0))::NUMERIC(4,3),
            now(),
            now()
        );
    END IF;

    -- Trade notification
    INSERT INTO notifications (
        id,
        user_id,
        market_id,
        type,
        title,
        message,
        link,
        created_at
    ) VALUES (
        gen_random_uuid(),
        p_user_id,
        p_market_id,
        'trade_executed',
        'Trade Executed',
        'Bought ' || ROUND(p_calculated_shares, 2)::TEXT || ' ' || UPPER(p_bet_side) || ' shares for $' || ROUND(p_bet_amount, 2)::TEXT,
        '/market/' || p_market_id,
        now()
    );

    -- Return results
    RETURN QUERY SELECT v_transaction_id, v_new_balance, v_new_shares;
END;
$function$
"
"public","execute_trade_lmsr_v2","CREATE OR REPLACE FUNCTION public.execute_trade_lmsr_v2(p_market_id uuid, p_user_id uuid, p_bet_amount numeric, p_bet_side character varying, p_expected_price numeric DEFAULT NULL::numeric)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_market RECORD;
    v_current_qy NUMERIC;
    v_current_qn NUMERIC;
    v_b NUMERIC;
    v_new_qy NUMERIC;
    v_new_qn NUMERIC;
    v_spot_price NUMERIC;
    v_execution_price NUMERIC;
    v_slippage NUMERIC;
    v_slippage_tolerance NUMERIC;
    v_side_boolean BOOLEAN;
    v_calculated_shares NUMERIC;
    v_total_fee NUMERIC;
    v_platform_fee NUMERIC;
    v_creator_fee NUMERIC;
    v_net_amount NUMERIC;
    v_user_balance NUMERIC;
    v_transaction_id UUID;
    v_user_account_id UUID;
    v_pool_account_id UUID;
    v_platform_account_id UUID;
    v_creator_fee_account_id UUID;
    v_gross_amount_cents BIGINT;
    v_net_amount_cents BIGINT;
    v_platform_fee_cents BIGINT;
    v_creator_fee_cents BIGINT;
    v_total_fee_cents BIGINT;  -- Added missing variable declaration for fee rounding fix
    v_transaction_group_id UUID := gen_random_uuid();
BEGIN
    -- 1. ACQUIRE ADVISORY LOCK on market
    PERFORM pg_advisory_xact_lock(hashtext(p_market_id::text));
    
    -- 2. GET CURRENT MARKET STATE
    SELECT id, qy, qn, b, status, creator_id
    INTO v_market
    FROM markets
    WHERE id = p_market_id
    FOR UPDATE;
    
    IF v_market IS NULL THEN
        RAISE EXCEPTION 'Market not found: %', p_market_id;
    END IF;
    
    IF v_market.status != 'active' THEN
        RAISE EXCEPTION 'Market is not open for trading. Status: %', v_market.status;
    END IF;
    
    v_current_qy := COALESCE(v_market.qy, 0);
    v_current_qn := COALESCE(v_market.qn, 0);
    v_b := COALESCE(v_market.b, 100 / LN(2) - 1);
    
    -- 3. PARSE SIDE
    v_side_boolean := LOWER(p_bet_side) IN ('yes', 'y', 'true', '1');
    
    -- 4. CALCULATE SPOT PRICE (for slippage check)
    IF v_side_boolean THEN
        v_spot_price := EXP(v_current_qy / v_b) / (EXP(v_current_qy / v_b) + EXP(v_current_qn / v_b));
    ELSE
        v_spot_price := EXP(v_current_qn / v_b) / (EXP(v_current_qy / v_b) + EXP(v_current_qn / v_b));
    END IF;
    
    -- 5. GET USER'S SLIPPAGE TOLERANCE (default 5%)
    SELECT COALESCE(slippage_tolerance, 5.00) / 100.0 
    INTO v_slippage_tolerance
    FROM profiles 
    WHERE id = p_user_id;
    
    v_slippage_tolerance := COALESCE(v_slippage_tolerance, 0.05);
    
    -- Fixed rounding: calculate fees in cents to prevent truncation losses
    -- Convert to cents immediately, calculate 1% fee, split deterministically
    v_gross_amount_cents := ROUND(p_bet_amount * 100);
    v_total_fee_cents := ROUND(v_gross_amount_cents * 0.01);  -- 1% fee in cents
    v_platform_fee_cents := v_total_fee_cents / 2;  -- Integer division (floor)
    v_creator_fee_cents := v_total_fee_cents - v_platform_fee_cents;  -- Remainder ensures sum = total
    v_net_amount_cents := v_gross_amount_cents - v_total_fee_cents;
    
    -- Convert back to dollars for compatibility with existing code
    v_total_fee := v_total_fee_cents / 100.0;
    v_platform_fee := v_platform_fee_cents / 100.0;
    v_creator_fee := v_creator_fee_cents / 100.0;
    v_net_amount := v_net_amount_cents / 100.0;
    
    -- 7. VALIDATE USER BALANCE
    SELECT balance INTO v_user_balance
    FROM profiles
    WHERE id = p_user_id
    FOR UPDATE;
    
    IF v_user_balance IS NULL OR v_user_balance < p_bet_amount THEN
        RAISE EXCEPTION 'Insufficient balance. Required: %, Available: %', 
            ROUND(p_bet_amount, 2), COALESCE(ROUND(v_user_balance, 2), 0);
    END IF;
    
    -- 8. CALCULATE SHARES using LMSR formula
    IF v_side_boolean THEN
        v_calculated_shares := v_b * LN(
            EXP(v_net_amount / v_b) * (EXP(v_current_qy / v_b) + EXP(v_current_qn / v_b)) - EXP(v_current_qn / v_b)
        ) - v_current_qy;
        v_new_qy := v_current_qy + v_calculated_shares;
        v_new_qn := v_current_qn;
    ELSE
        v_calculated_shares := v_b * LN(
            EXP(v_net_amount / v_b) * (EXP(v_current_qy / v_b) + EXP(v_current_qn / v_b)) - EXP(v_current_qy / v_b)
        ) - v_current_qn;
        v_new_qy := v_current_qy;
        v_new_qn := v_current_qn + v_calculated_shares;
    END IF;
    
    v_calculated_shares := ROUND(v_calculated_shares, 4);
    
    -- Fixed to use v_net_amount instead of p_bet_amount for price_per_share
    -- This ensures price represents actual market price (net of fees), not gross cost
    -- 9. CALCULATE EXECUTION PRICE
    v_execution_price := ROUND(v_net_amount / v_calculated_shares, 4);
    
    -- 10. VALIDATE SLIPPAGE (using user's tolerance against EXECUTION price)
    IF p_expected_price IS NOT NULL THEN
        v_slippage := ABS(v_execution_price - p_expected_price) / NULLIF(p_expected_price, 0);
        IF v_slippage > v_slippage_tolerance THEN
            RAISE EXCEPTION 'Price slippage too high: %. Execution price: %, Expected: %, Your tolerance: %', 
                ROUND(v_slippage * 100, 2) || '%', ROUND(v_execution_price, 4), ROUND(p_expected_price, 4),
                ROUND(v_slippage_tolerance * 100, 1) || '%';
        END IF;
    END IF;
    
    -- 11. DEDUCT FROM USER BALANCE
    UPDATE profiles
    SET balance = balance - p_bet_amount
    WHERE id = p_user_id;
    
    -- 12. GET OR CREATE LEDGER ACCOUNTS
    SELECT get_or_create_account(p_user_id, 'user') INTO v_user_account_id;
    SELECT get_or_create_account(p_market_id, 'market_pool') INTO v_pool_account_id;
    SELECT get_or_create_account('00000000-0000-0000-0000-000000000001'::uuid, 'platform') INTO v_platform_account_id;
    SELECT get_or_create_account(p_market_id, 'market_creator_fees') INTO v_creator_fee_account_id;
    
    -- 13. CREATE LEDGER ENTRIES
    PERFORM create_ledger_entry(
        v_user_account_id, p_user_id, 'debit', v_gross_amount_cents, 'trade',
        NULL, p_market_id, 'user', v_transaction_group_id, 
        'Buy ' || CASE WHEN v_side_boolean THEN 'YES' ELSE 'NO' END || ' shares'
    );
    
    PERFORM create_ledger_entry(
        v_pool_account_id, p_user_id, 'credit', v_net_amount_cents, 'trade',
        NULL, p_market_id, 'market_pool', v_transaction_group_id,
        'Market pool credit for trade'
    );
    
    PERFORM create_ledger_entry(
        v_platform_account_id, p_user_id, 'credit', v_platform_fee_cents, 'platform_fee',
        NULL, p_market_id, 'platform', v_transaction_group_id,
        'Platform fee'
    );
    
    PERFORM create_ledger_entry(
        v_creator_fee_account_id, p_user_id, 'credit', v_creator_fee_cents, 'creator_fee',
        NULL, p_market_id, 'market_creator_fees', v_transaction_group_id,
        'Creator fee'
    );
    
    -- 14. CREATE SHARES LEDGER ENTRIES
    PERFORM create_shares_ledger_entry(
        p_market_id, p_user_id, 'user', v_side_boolean,
        0::NUMERIC, v_calculated_shares, 'buy',
        'Buy ' || CASE WHEN v_side_boolean THEN 'YES' ELSE 'NO' END || ' shares',
        '{}'::JSONB
    );
    
    PERFORM create_shares_ledger_entry(
        p_market_id, NULL::UUID, 'market', v_side_boolean,
        v_calculated_shares, 0::NUMERIC, 'buy',
        'Market issued shares',
        '{}'::JSONB
    );
    
    -- 15. INSERT INTO FEES TABLE
    INSERT INTO fees (
        user_id, market_id, transaction_type, original_amount, fee_amount,
        fee_percentage, net_amount, fee_type, paid_out, created_at
    ) VALUES (
        v_market.creator_id, p_market_id, 'buy', p_bet_amount, v_creator_fee,
        0.005, v_creator_fee, 'creator', false, NOW()
    );
    
    INSERT INTO fees (
        user_id, market_id, transaction_type, original_amount, fee_amount,
        fee_percentage, net_amount, fee_type, paid_out, created_at
    ) VALUES (
        p_user_id, p_market_id, 'buy', p_bet_amount, v_platform_fee,
        0.005, v_platform_fee, 'site', false, NOW()
    );
    
    -- 16. UPDATE MARKETS TABLE
    UPDATE markets
    SET qy = ROUND(v_new_qy, 4),
        qn = ROUND(v_new_qn, 4),
        yes_shares = COALESCE(yes_shares, 0) + CASE WHEN v_side_boolean THEN v_calculated_shares ELSE 0 END,
        no_shares = COALESCE(no_shares, 0) + CASE WHEN NOT v_side_boolean THEN v_calculated_shares ELSE 0 END,
        total_volume = COALESCE(total_volume, 0) + p_bet_amount,
        creator_fees_earned = COALESCE(creator_fees_earned, 0) + v_creator_fee,
        updated_at = NOW()
    WHERE id = p_market_id;
    
    -- 17. UPDATE/INSERT POSITION
    INSERT INTO positions (user_id, market_id, side, shares, avg_price, amount_invested)
    VALUES (p_user_id, p_market_id, v_side_boolean, v_calculated_shares, v_execution_price, p_bet_amount)
    ON CONFLICT (user_id, market_id, side) DO UPDATE SET
        shares = positions.shares + EXCLUDED.shares,
        avg_price = (positions.avg_price * positions.shares + EXCLUDED.avg_price * EXCLUDED.shares) / (positions.shares + EXCLUDED.shares),
        amount_invested = positions.amount_invested + EXCLUDED.amount_invested;
    
    -- 18. CREATE TRANSACTION RECORD (using correct columns from working version)
    INSERT INTO transactions (
        id, user_id, market_id, type, amount, shares, price_per_share, cost_basis, side, created_at
    ) VALUES (
        gen_random_uuid(), p_user_id, p_market_id, 'buy',
        p_bet_amount, v_calculated_shares, v_execution_price, p_bet_amount, 
        CASE WHEN v_side_boolean THEN 'YES' ELSE 'NO' END, NOW()
    )
    RETURNING id INTO v_transaction_id;
    
    -- 19. CREATE NOTIFICATION
    INSERT INTO notifications (user_id, type, title, message, market_id, created_at)
    VALUES (
        p_user_id,
        'trade_executed',
        'Trade Executed',
        'Bought ' || ROUND(v_calculated_shares, 2) || ' ' || 
        CASE WHEN v_side_boolean THEN 'YES' ELSE 'NO' END || 
        ' shares at $' || ROUND(v_execution_price, 4) || ' per share for $' || ROUND(p_bet_amount, 2),
        p_market_id,
        NOW()
    );
    
    RETURN jsonb_build_object(
        'success', true,
        'transaction_id', v_transaction_id,
        'shares', ROUND(v_calculated_shares, 4),
        'execution_price', ROUND(v_execution_price, 4),
        'spot_price', ROUND(v_spot_price, 4),
        'amount', ROUND(p_bet_amount, 4),
        'fees', ROUND(v_total_fee, 4),
        'net_amount', ROUND(v_net_amount, 4)
    );
END;
$function$
"
"public","force_settle_pending_settlements","CREATE OR REPLACE FUNCTION public.force_settle_pending_settlements()
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_market RECORD;
  v_contest RECORD;
  v_position RECORD;
  v_vote RECORD;
  v_settlement_bond RECORD;
  v_results JSONB := '[]'::JSONB;
  v_result JSONB;
  v_winning_outcome_text TEXT;
  v_winning_outcome_bool BOOLEAN;
  v_yes_votes INT;
  v_no_votes INT;
  v_cancel_votes INT;
  v_total_votes INT;
  v_payout NUMERIC;
  v_remaining_liquidity NUMERIC;
  v_winning_side TEXT;
  v_max_votes INT;
  v_proposal_outcome TEXT;
  v_contested_outcome TEXT;
  v_total_losing_bonds NUMERIC;
  v_total_winning_bonds NUMERIC;
  v_winner_bond NUMERIC;
  v_winner_share NUMERIC;
  v_bonus_amount NUMERIC;
  v_total_payout NUMERIC;
  v_initial_liquidity NUMERIC;
  v_liquidity_to_return NUMERIC;
  v_liquidity_sweep NUMERIC;
  v_debit_account_id UUID;
  v_credit_account_id UUID;
  v_txn_group_id UUID;
BEGIN
  -- ============================================
  -- PART A: Process UNCONTESTED settlements
  -- ============================================
  FOR v_market IN
    SELECT m.*, sb.id as bond_id, sb.creator_id as proposer_id, sb.bond_amount as proposal_bond_amount,
           sb.outcome_chosen_text as proposed_outcome
    FROM markets m
    JOIN settlement_bonds sb ON sb.market_id = m.id AND sb.status = 'active'
    WHERE m.is_private = true
      AND m.settlement_status = 'pending_contest'
      AND m.contest_deadline < NOW()
      AND NOT EXISTS (
        SELECT 1 FROM settlement_contests sc 
        WHERE sc.market_id = m.id AND sc.status IN ('active', 'voting')
      )
  LOOP
    BEGIN
      v_winning_outcome_bool := CASE 
        WHEN LOWER(v_market.proposed_outcome) = 'yes' THEN TRUE
        WHEN LOWER(v_market.proposed_outcome) = 'no' THEN FALSE
        ELSE NULL
      END;

      UPDATE markets SET 
        status = 'settled',
        settlement_status = 'settled',
        outcome_text = v_market.proposed_outcome,
        outcome = v_winning_outcome_bool,
        winning_side = v_winning_outcome_bool,
        settled_at = NOW()
      WHERE id = v_market.id;

      UPDATE settlement_bonds SET status = 'returned', resolved_at = NOW(), payout_amount = bond_amount
      WHERE id = v_market.bond_id;

      IF COALESCE(v_market.proposal_bond_amount, 0) > 0 THEN
        INSERT INTO transactions (user_id, market_id, type, amount, description)
        VALUES (v_market.proposer_id, v_market.id, 'bond_payout', ROUND(v_market.proposal_bond_amount, 2), 
                'Settlement bond returned - uncontested');

        UPDATE profiles SET balance = balance + ROUND(v_market.proposal_bond_amount, 2) WHERE id = v_market.proposer_id;

        v_txn_group_id := gen_random_uuid();
        v_debit_account_id := get_or_create_account(v_market.proposer_id, 'settlement_bond');
        v_credit_account_id := get_or_create_account(v_market.proposer_id, 'user');
        
        PERFORM create_ledger_entry(
          v_debit_account_id,
          ROUND(v_market.proposal_bond_amount * 100)::BIGINT,
          'debit',
          'bond_return',
          v_market.id,
          v_txn_group_id,
          jsonb_build_object('type', 'uncontested_bond_return', 'market_id', v_market.id)
        );
        
        PERFORM create_ledger_entry(
          v_credit_account_id,
          ROUND(v_market.proposal_bond_amount * 100)::BIGINT,
          'credit',
          'bond_return',
          v_market.id,
          v_txn_group_id,
          jsonb_build_object('type', 'uncontested_bond_return', 'market_id', v_market.id)
        );

        INSERT INTO notifications (user_id, market_id, type, title, message)
        VALUES (v_market.proposer_id, v_market.id, 'settlement_bond_returned', 'Settlement Bond Returned',
                'Your settlement proposal was uncontested. Bond returned: $' || ROUND(v_market.proposal_bond_amount, 2)::TEXT);
      ELSE
        INSERT INTO notifications (user_id, market_id, type, title, message)
        VALUES (v_market.proposer_id, v_market.id, 'settlement_bond_returned', 'Settlement Complete',
                'Your settlement proposal was uncontested and has been finalized.');
      END IF;

      -- Pay out winning positions
      FOR v_position IN
        SELECT p.*, pr.id as profile_id
        FROM positions p
        JOIN profiles pr ON pr.id = p.user_id
        WHERE p.market_id = v_market.id AND p.shares > 0
      LOOP
        IF (v_market.proposed_outcome = 'yes' AND v_position.side = TRUE) OR
           (v_market.proposed_outcome = 'no' AND v_position.side = FALSE) THEN
          v_payout := ROUND(v_position.shares, 2);
          
          UPDATE profiles SET balance = balance + v_payout WHERE id = v_position.user_id;
          
          INSERT INTO transactions (user_id, market_id, type, amount, description)
          VALUES (v_position.user_id, v_market.id, 'settlement_payout', v_payout,
                  'Won: ' || ROUND(v_position.shares, 2) || ' shares paid out');

          INSERT INTO notifications (user_id, market_id, type, title, message)
          VALUES (v_position.user_id, v_market.id, 'settlement_win', 'You Won!',
                  'You received $' || ROUND(v_payout, 2)::TEXT || ' from market settlement.');
        ELSE
          INSERT INTO notifications (user_id, market_id, type, title, message)
          VALUES (v_position.user_id, v_market.id, 'settlement_loss', 'Market Settled',
                  'The market settled against your position. You lost $' || ROUND(v_position.amount_invested, 2)::TEXT);
        END IF;
      END LOOP;

      -- Query actual remaining liquidity AFTER all payouts, not cached value from loop start
      SELECT COALESCE(liquidity_pool, 0) INTO v_remaining_liquidity FROM markets WHERE id = v_market.id;
      v_initial_liquidity := (COALESCE(v_market.b, 0) + 1) * LN(2);
      v_liquidity_to_return := ROUND(LEAST(v_remaining_liquidity, v_initial_liquidity), 2);
      v_liquidity_sweep := ROUND(GREATEST(v_remaining_liquidity - v_liquidity_to_return, 0), 2);
      
      IF v_liquidity_to_return > 0.01 THEN
        UPDATE profiles SET balance = balance + v_liquidity_to_return WHERE id = v_market.creator_id;
        
        INSERT INTO transactions (user_id, market_id, type, amount, description)
        VALUES (v_market.creator_id, v_market.id, 'liquidity_return', v_liquidity_to_return,
                'Liquidity returned (capped at initial: $' || ROUND(v_initial_liquidity, 2) || ')');

        INSERT INTO notifications (user_id, market_id, type, title, message)
        VALUES (v_market.creator_id, v_market.id, 'liquidity_returned', 'Liquidity Returned',
                'Your liquidity of $' || ROUND(v_liquidity_to_return, 2)::TEXT || ' has been returned.');
      END IF;
      
      IF v_liquidity_sweep > 0.01 THEN
        INSERT INTO transactions (user_id, market_id, type, amount, description)
        VALUES (v_market.creator_id, v_market.id, 'liquidity_sweep', v_liquidity_sweep,
                'Excess liquidity swept to platform ($' || ROUND(v_liquidity_sweep, 2) || ' above initial cap)');
      END IF;

      v_result := jsonb_build_object(
        'market_id', v_market.id,
        'title', v_market.title,
        'type', 'uncontested',
        'success', true,
        'outcome', v_market.proposed_outcome,
        'liquidity_returned', v_liquidity_to_return,
        'liquidity_sweep', v_liquidity_sweep
      );
      v_results := v_results || v_result;

    EXCEPTION WHEN OTHERS THEN
      v_result := jsonb_build_object(
        'market_id', v_market.id,
        'title', v_market.title,
        'type', 'uncontested',
        'success', false,
        'error', SQLERRM
      );
      v_results := v_results || v_result;
    END;
  END LOOP;

  -- ============================================
  -- PART B: Process CONTESTED settlements
  -- ============================================
  FOR v_contest IN
    SELECT sc.*, m.id as market_id, m.title as market_title, m.creator_id, m.liquidity_pool, m.b as market_b,
           sb.id as bond_id, sb.creator_id as proposer_id, sb.bond_amount as proposal_bond_amount,
           sb.outcome_chosen_text as proposal_outcome
    FROM settlement_contests sc
    JOIN markets m ON m.id = sc.market_id
    JOIN settlement_bonds sb ON sb.market_id = m.id AND sb.status = 'active'
    WHERE sc.status IN ('active', 'voting')
      AND sc.vote_deadline < NOW()
      AND m.status != 'settled'
  LOOP
    BEGIN
      v_proposal_outcome := LOWER(v_contest.proposal_outcome);
      v_contested_outcome := LOWER(v_contest.contested_outcome_text);
      
      SELECT 
        COALESCE(SUM(CASE WHEN LOWER(vote_outcome_text) = 'yes' THEN 1 ELSE 0 END), 0),
        COALESCE(SUM(CASE WHEN LOWER(vote_outcome_text) = 'no' THEN 1 ELSE 0 END), 0),
        COALESCE(SUM(CASE WHEN LOWER(vote_outcome_text) = 'cancel' THEN 1 ELSE 0 END), 0)
      INTO v_yes_votes, v_no_votes, v_cancel_votes
      FROM settlement_votes
      WHERE contest_id = v_contest.id;

      IF v_proposal_outcome = 'yes' THEN
        v_yes_votes := v_yes_votes + 1;
      ELSIF v_proposal_outcome = 'no' THEN
        v_no_votes := v_no_votes + 1;
      ELSIF v_proposal_outcome = 'cancel' THEN
        v_cancel_votes := v_cancel_votes + 1;
      END IF;
      
      IF v_contested_outcome = 'yes' THEN
        v_yes_votes := v_yes_votes + 1;
      ELSIF v_contested_outcome = 'no' THEN
        v_no_votes := v_no_votes + 1;
      ELSIF v_contested_outcome = 'cancel' THEN
        v_cancel_votes := v_cancel_votes + 1;
      END IF;

      v_total_votes := v_yes_votes + v_no_votes + v_cancel_votes;

      v_max_votes := GREATEST(v_yes_votes, v_no_votes, v_cancel_votes);
      
      IF v_yes_votes = v_max_votes AND v_no_votes < v_max_votes AND v_cancel_votes < v_max_votes THEN
        v_winning_outcome_text := 'yes';
      ELSIF v_no_votes = v_max_votes AND v_yes_votes < v_max_votes AND v_cancel_votes < v_max_votes THEN
        v_winning_outcome_text := 'no';
      ELSIF v_cancel_votes = v_max_votes AND v_yes_votes < v_max_votes AND v_no_votes < v_max_votes THEN
        v_winning_outcome_text := 'cancel';
      ELSE
        IF (v_proposal_outcome = 'yes' AND v_yes_votes = v_max_votes) OR
           (v_proposal_outcome = 'no' AND v_no_votes = v_max_votes) OR
           (v_proposal_outcome = 'cancel' AND v_cancel_votes = v_max_votes) THEN
          v_winning_outcome_text := v_proposal_outcome;
        ELSE
          v_winning_outcome_text := 'cancel';
        END IF;
      END IF;

      v_winning_outcome_bool := CASE 
        WHEN v_winning_outcome_text = 'yes' THEN TRUE
        WHEN v_winning_outcome_text = 'no' THEN FALSE
        ELSE NULL
      END;

      IF v_winning_outcome_text = 'cancel' THEN
        v_winning_side := 'cancel';
      ELSIF v_winning_outcome_text = v_contested_outcome THEN
        v_winning_side := 'contest';
      ELSE
        v_winning_side := 'proposal';
      END IF;

      IF v_winning_outcome_text = 'cancel' THEN
        UPDATE markets SET 
          status = 'cancelled',
          settlement_status = 'settled',
          outcome_text = 'cancel',
          outcome = NULL,
          winning_side = NULL,
          settled_at = NOW()
        WHERE id = v_contest.market_id;
      ELSE
        UPDATE markets SET 
          status = 'settled',
          settlement_status = 'settled',
          outcome_text = v_winning_outcome_text,
          outcome = v_winning_outcome_bool,
          winning_side = v_winning_outcome_bool,
          settled_at = NOW()
        WHERE id = v_contest.market_id;
      END IF;

      UPDATE settlement_contests SET 
        status = 'resolved',
        resolution_outcome_text = v_winning_outcome_text,
        resolved_at = NOW()
      WHERE id = v_contest.id;

      IF v_winning_side = 'proposal' THEN
        v_total_losing_bonds := v_contest.contest_bond_amount;
        v_total_winning_bonds := v_contest.proposal_bond_amount;
      ELSIF v_winning_side = 'contest' THEN
        v_total_losing_bonds := v_contest.proposal_bond_amount;
        v_total_winning_bonds := v_contest.contest_bond_amount;
      ELSE
        v_total_losing_bonds := v_contest.proposal_bond_amount + v_contest.contest_bond_amount;
        v_total_winning_bonds := 0;
      END IF;
      
      FOR v_vote IN
        SELECT sv.*, 
               CASE WHEN LOWER(sv.vote_outcome_text) = v_winning_outcome_text THEN true ELSE false END as is_winner
        FROM settlement_votes sv
        WHERE sv.contest_id = v_contest.id
      LOOP
        IF v_vote.is_winner THEN
          v_total_winning_bonds := v_total_winning_bonds + v_vote.vote_bond_amount;
        ELSE
          v_total_losing_bonds := v_total_losing_bonds + v_vote.vote_bond_amount;
        END IF;
        
        UPDATE settlement_votes SET is_correct = v_vote.is_winner WHERE id = v_vote.id;
      END LOOP;

      IF v_winning_side = 'proposal' THEN
        IF v_total_winning_bonds > 0 THEN
          v_winner_share := v_contest.proposal_bond_amount / v_total_winning_bonds;
        ELSE
          v_winner_share := 1;
        END IF;
        v_bonus_amount := ROUND(v_total_losing_bonds * v_winner_share, 2);
        v_total_payout := ROUND(v_contest.proposal_bond_amount + v_bonus_amount, 2);
        
        UPDATE settlement_bonds SET status = 'won', resolved_at = NOW(), payout_amount = v_total_payout
        WHERE id = v_contest.bond_id;
        
        IF v_total_payout > 0 THEN
          UPDATE profiles SET balance = balance + v_total_payout WHERE id = v_contest.proposer_id;
          
          INSERT INTO transactions (user_id, market_id, type, amount, description)
          VALUES (v_contest.proposer_id, v_contest.market_id, 'bond_payout', v_total_payout,
                  'Proposal won - bond: $' || ROUND(v_contest.proposal_bond_amount, 2) || ' + bonus: $' || ROUND(v_bonus_amount, 2));
        END IF;

        INSERT INTO notifications (user_id, market_id, type, title, message)
        VALUES (v_contest.proposer_id, v_contest.market_id, 'settlement_win', 'Your Proposal Won!',
                'Bond: $' || ROUND(v_contest.proposal_bond_amount, 2)::TEXT || 
                ', Bonus: $' || ROUND(v_bonus_amount, 2)::TEXT || ', Total: $' || ROUND(v_total_payout, 2)::TEXT);

        UPDATE settlement_contests SET payout_amount = 0 WHERE id = v_contest.id;
        
        INSERT INTO notifications (user_id, market_id, type, title, message)
        VALUES (v_contest.contestant_id, v_contest.market_id, 'settlement_loss', 'Contest Failed',
                'You lost your $' || ROUND(v_contest.contest_bond_amount, 2)::TEXT || ' bond.');

      ELSIF v_winning_side = 'contest' THEN
        IF v_total_winning_bonds > 0 THEN
          v_winner_share := v_contest.contest_bond_amount / v_total_winning_bonds;
        ELSE
          v_winner_share := 1;
        END IF;
        v_bonus_amount := ROUND(v_total_losing_bonds * v_winner_share, 2);
        v_total_payout := ROUND(v_contest.contest_bond_amount + v_bonus_amount, 2);
        
        UPDATE settlement_contests SET payout_amount = v_total_payout WHERE id = v_contest.id;
        
        IF v_total_payout > 0 THEN
          UPDATE profiles SET balance = balance + v_total_payout WHERE id = v_contest.contestant_id;
          
          INSERT INTO transactions (user_id, market_id, type, amount, description)
          VALUES (v_contest.contestant_id, v_contest.market_id, 'bond_payout', v_total_payout,
                  'Contest won - bond: $' || ROUND(v_contest.contest_bond_amount, 2) || ' + bonus: $' || ROUND(v_bonus_amount, 2));
        END IF;

        INSERT INTO notifications (user_id, market_id, type, title, message)
        VALUES (v_contest.contestant_id, v_contest.market_id, 'settlement_win', 'Your Contest Won!',
                'Bond: $' || ROUND(v_contest.contest_bond_amount, 2)::TEXT || 
                ', Bonus: $' || ROUND(v_bonus_amount, 2)::TEXT || ', Total: $' || ROUND(v_total_payout, 2)::TEXT);

        UPDATE settlement_bonds SET status = 'lost', resolved_at = NOW(), payout_amount = 0
        WHERE id = v_contest.bond_id;
        
        INSERT INTO notifications (user_id, market_id, type, title, message)
        VALUES (v_contest.proposer_id, v_contest.market_id, 'settlement_loss', 'Proposal Rejected',
                'You lost your $' || ROUND(v_contest.proposal_bond_amount, 2)::TEXT || ' bond.');

      ELSE
        UPDATE settlement_bonds SET status = 'lost', resolved_at = NOW(), payout_amount = 0
        WHERE id = v_contest.bond_id;
        UPDATE settlement_contests SET payout_amount = 0 WHERE id = v_contest.id;

        INSERT INTO notifications (user_id, market_id, type, title, message)
        VALUES (v_contest.proposer_id, v_contest.market_id, 'settlement_loss', 'Market Cancelled',
                'You lost your $' || ROUND(v_contest.proposal_bond_amount, 2)::TEXT || ' bond.');

        INSERT INTO notifications (user_id, market_id, type, title, message)
        VALUES (v_contest.contestant_id, v_contest.market_id, 'settlement_loss', 'Market Cancelled',
                'You lost your $' || ROUND(v_contest.contest_bond_amount, 2)::TEXT || ' bond.');
      END IF;

      FOR v_vote IN
        SELECT sv.*, pr.id as profile_id
        FROM settlement_votes sv
        JOIN profiles pr ON pr.id = sv.voter_id
        WHERE sv.contest_id = v_contest.id
      LOOP
        IF LOWER(v_vote.vote_outcome_text) = v_winning_outcome_text THEN
          IF v_total_winning_bonds > 0 THEN
            v_winner_share := v_vote.vote_bond_amount / v_total_winning_bonds;
          ELSE
            v_winner_share := 0;
          END IF;
          v_bonus_amount := ROUND(v_total_losing_bonds * v_winner_share, 2);
          v_total_payout := ROUND(v_vote.vote_bond_amount + v_bonus_amount, 2);
          
          UPDATE settlement_votes SET payout_amount = v_total_payout, is_correct = true WHERE id = v_vote.id;
          
          IF v_total_payout > 0 THEN
            UPDATE profiles SET balance = balance + v_total_payout WHERE id = v_vote.voter_id;
            
            INSERT INTO transactions (user_id, market_id, type, amount, description)
            VALUES (v_vote.voter_id, v_contest.market_id, 'bond_payout', v_total_payout,
                    'Correct vote - bond: $' || ROUND(v_vote.vote_bond_amount, 2) || ' + bonus: $' || ROUND(v_bonus_amount, 2));
          END IF;

          INSERT INTO notifications (user_id, market_id, type, title, message)
          VALUES (v_vote.voter_id, v_contest.market_id, 'settlement_win', 'Correct Vote!',
                  'Bond: $' || ROUND(v_vote.vote_bond_amount, 2)::TEXT || 
                  ', Bonus: $' || ROUND(v_bonus_amount, 2)::TEXT || ', Total: $' || ROUND(v_total_payout, 2)::TEXT);
        ELSE
          UPDATE settlement_votes SET payout_amount = 0, is_correct = false WHERE id = v_vote.id;
          
          INSERT INTO notifications (user_id, market_id, type, title, message)
          VALUES (v_vote.voter_id, v_contest.market_id, 'settlement_loss', 'Vote Lost',
                  'You lost your $' || ROUND(v_vote.vote_bond_amount, 2)::TEXT || ' bond.');
        END IF;
      END LOOP;

      -- Handle position payouts
      IF v_winning_outcome_text != 'cancel' THEN
        FOR v_position IN
          SELECT p.*, pr.id as profile_id
          FROM positions p
          JOIN profiles pr ON pr.id = p.user_id
          WHERE p.market_id = v_contest.market_id AND p.shares > 0
        LOOP
          IF (v_winning_outcome_text = 'yes' AND v_position.side = TRUE) OR
             (v_winning_outcome_text = 'no' AND v_position.side = FALSE) THEN
            v_payout := ROUND(v_position.shares, 2);
            
            UPDATE profiles SET balance = balance + v_payout WHERE id = v_position.user_id;
            
            INSERT INTO transactions (user_id, market_id, type, amount, description)
            VALUES (v_position.user_id, v_contest.market_id, 'settlement_payout', v_payout,
                    'Won: ' || ROUND(v_position.shares, 2) || ' shares');

            INSERT INTO notifications (user_id, market_id, type, title, message)
            VALUES (v_position.user_id, v_contest.market_id, 'settlement_win', 'You Won!',
                    'You received $' || ROUND(v_payout, 2)::TEXT || ' from market settlement.');
          ELSE
            INSERT INTO notifications (user_id, market_id, type, title, message)
            VALUES (v_position.user_id, v_contest.market_id, 'settlement_loss', 'Market Settled',
                    'The market settled against your position.');
          END IF;
        END LOOP;
      ELSE
        FOR v_position IN
          SELECT p.*, pr.id as profile_id
          FROM positions p
          JOIN profiles pr ON pr.id = p.user_id
          WHERE p.market_id = v_contest.market_id AND p.shares > 0
        LOOP
          v_payout := ROUND(v_position.amount_invested, 2);
          
          UPDATE profiles SET balance = balance + v_payout WHERE id = v_position.user_id;
          
          INSERT INTO transactions (user_id, market_id, type, amount, description)
          VALUES (v_position.user_id, v_contest.market_id, 'settlement_refund', v_payout,
                  'Market cancelled - position refunded');

          INSERT INTO notifications (user_id, market_id, type, title, message)
          VALUES (v_position.user_id, v_contest.market_id, 'market_cancelled', 'Market Cancelled',
                  'Your investment of $' || ROUND(v_payout, 2)::TEXT || ' has been refunded.');
        END LOOP;
      END IF;

      -- Query actual remaining liquidity AFTER all payouts, not cached value from loop start
      SELECT COALESCE(liquidity_pool, 0) INTO v_remaining_liquidity FROM markets WHERE id = v_contest.market_id;
      v_initial_liquidity := (COALESCE(v_contest.market_b, 0) + 1) * LN(2);
      v_liquidity_to_return := ROUND(LEAST(v_remaining_liquidity, v_initial_liquidity), 2);
      v_liquidity_sweep := ROUND(GREATEST(v_remaining_liquidity - v_liquidity_to_return, 0), 2);
      
      IF v_liquidity_to_return > 0.01 THEN
        UPDATE profiles SET balance = balance + v_liquidity_to_return WHERE id = v_contest.creator_id;
        
        INSERT INTO transactions (user_id, market_id, type, amount, description)
        VALUES (v_contest.creator_id, v_contest.market_id, 'liquidity_return', v_liquidity_to_return,
                'Liquidity returned');

        INSERT INTO notifications (user_id, market_id, type, title, message)
        VALUES (v_contest.creator_id, v_contest.market_id, 'liquidity_returned', 'Liquidity Returned',
                'Your liquidity of $' || ROUND(v_liquidity_to_return, 2)::TEXT || ' has been returned.');
      END IF;
      
      IF v_liquidity_sweep > 0.01 THEN
        INSERT INTO transactions (user_id, market_id, type, amount, description)
        VALUES (v_contest.creator_id, v_contest.market_id, 'liquidity_sweep', v_liquidity_sweep,
                'Excess liquidity swept to platform');
      END IF;

      PERFORM payout_bonds_to_ledger(v_contest.market_id, v_winning_side);

      v_result := jsonb_build_object(
        'market_id', v_contest.market_id,
        'title', v_contest.market_title,
        'type', 'contested',
        'success', true,
        'outcome', v_winning_outcome_text,
        'winning_side', v_winning_side,
        'votes', jsonb_build_object('yes', v_yes_votes, 'no', v_no_votes, 'cancel', v_cancel_votes),
        'liquidity_returned', v_liquidity_to_return,
        'liquidity_sweep', v_liquidity_sweep
      );
      v_results := v_results || v_result;

    EXCEPTION WHEN OTHERS THEN
      v_result := jsonb_build_object(
        'market_id', v_contest.market_id,
        'title', v_contest.market_title,
        'type', 'contested',
        'success', false,
        'error', SQLERRM
      );
      v_results := v_results || v_result;
    END;
  END LOOP;

  RETURN v_results;
END;
$function$
"
"public","gen_random_bytes","CREATE OR REPLACE FUNCTION public.gen_random_bytes(integer)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_random_bytes$function$
"
"public","gen_random_uuid","CREATE OR REPLACE FUNCTION public.gen_random_uuid()
 RETURNS uuid
 LANGUAGE c
 PARALLEL SAFE
AS '$libdir/pgcrypto', $function$pg_random_uuid$function$
"
"public","gen_salt","CREATE OR REPLACE FUNCTION public.gen_salt(text, integer)
 RETURNS text
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_gen_salt_rounds$function$
"
"public","gen_salt","CREATE OR REPLACE FUNCTION public.gen_salt(text)
 RETURNS text
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_gen_salt$function$
"
"public","get_account_balance","CREATE OR REPLACE FUNCTION public.get_account_balance(p_account_type text, p_reference_id uuid DEFAULT NULL::uuid)
 RETURNS numeric
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_balance_cents BIGINT;
BEGIN
  SELECT lbs.balance_cents INTO v_balance_cents
  FROM ledger_accounts la
  JOIN ledger_balance_snapshots lbs ON la.id = lbs.account_id
  WHERE la.account_type = p_account_type
    AND (p_reference_id IS NULL OR la.reference_id = p_reference_id);
  
  RETURN COALESCE(v_balance_cents, 0) / 100.0;
END;
$function$
"
"public","get_or_create_account","CREATE OR REPLACE FUNCTION public.get_or_create_account(p_entity_id uuid, p_account_type text)
 RETURNS uuid
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_account_id UUID;
    v_fixed_platform_id UUID := '00000000-0000-0000-0000-000000000001'::UUID;
    v_fixed_clearing_id UUID := '00000000-0000-0000-0000-00000000C1EA'::UUID;
BEGIN
    -- Special handling for platform account (always use fixed UUID)
    IF p_account_type = 'platform' THEN
        v_account_id := v_fixed_platform_id;
        
        -- Check if platform account exists, if not create it
        IF NOT EXISTS (SELECT 1 FROM ledger_accounts WHERE id = v_account_id) THEN
            INSERT INTO ledger_accounts (id, account_type, reference_id, entity_id, created_at, metadata)
            VALUES (
                v_account_id,
                'platform',
                '00000000-0000-0000-0000-000000000000'::UUID,
                '00000000-0000-0000-0000-000000000000'::UUID,
                NOW(),
                '{""name"": ""Platform Account""}'::jsonb
            );
            
            -- Create initial balance snapshot
            INSERT INTO ledger_balance_snapshots (account_id, balance_cents, updated_at)
            VALUES (v_account_id, 0, NOW());
            
            RAISE NOTICE '[Ledger] Created platform account with balance snapshot';
        END IF;
        
        RETURN v_account_id;
    END IF;
    
    -- Special handling for external clearing account (always use fixed UUID)
    IF p_account_type = 'external_clearing' THEN
        v_account_id := v_fixed_clearing_id;
        
        -- Check if clearing account exists, if not create it
        IF NOT EXISTS (SELECT 1 FROM ledger_accounts WHERE id = v_account_id) THEN
            INSERT INTO ledger_accounts (id, account_type, reference_id, entity_id, created_at, metadata)
            VALUES (
                v_account_id,
                'external_clearing',
                v_fixed_clearing_id,
                v_fixed_clearing_id,
                NOW(),
                '{""name"": ""External Clearing Account"", ""tracking_code"": ""external_clearing_account""}'::jsonb
            );
            
            -- Create initial balance snapshot
            INSERT INTO ledger_balance_snapshots (account_id, balance_cents, updated_at)
            VALUES (v_account_id, 0, NOW());
            
            RAISE NOTICE '[Ledger] Created external clearing account with balance snapshot';
        END IF;
        
        RETURN v_account_id;
    END IF;
    
    -- Try to find existing account
    SELECT id INTO v_account_id
    FROM ledger_accounts
    WHERE reference_id = p_entity_id AND account_type = p_account_type
    LIMIT 1;
    
    -- If account doesn't exist, create it
    IF v_account_id IS NULL THEN
        INSERT INTO ledger_accounts (account_type, reference_id, entity_id, created_at, metadata)
        VALUES (p_account_type, p_entity_id, p_entity_id, NOW(), '{}'::jsonb)
        RETURNING id INTO v_account_id;
        
        -- Always create initial balance snapshot for new accounts
        INSERT INTO ledger_balance_snapshots (account_id, balance_cents, updated_at)
        VALUES (v_account_id, 0, NOW());
        
        RAISE NOTICE '[Ledger] Created new % account (%) with balance snapshot', p_account_type, v_account_id;
    ELSE
        -- Account exists, ensure balance snapshot exists
        IF NOT EXISTS (SELECT 1 FROM ledger_balance_snapshots WHERE account_id = v_account_id) THEN
            INSERT INTO ledger_balance_snapshots (account_id, balance_cents, updated_at)
            VALUES (v_account_id, 0, NOW());
            
            RAISE NOTICE '[Ledger] Created missing balance snapshot for existing account %', v_account_id;
        END IF;
    END IF;
    
    RETURN v_account_id;
END;
$function$
"
"public","get_platform_balance","CREATE OR REPLACE FUNCTION public.get_platform_balance()
 RETURNS TABLE(current_balance numeric)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT COALESCE(SUM(amount), 0)::NUMERIC as current_balance
    FROM platform_ledger;
END;
$function$
"
"public","get_platform_balance_summary","CREATE OR REPLACE FUNCTION public.get_platform_balance_summary()
 RETURNS TABLE(account_type text, total_balance_cents bigint, account_count bigint)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    la.account_type,
    COALESCE(SUM(lbs.balance_cents), 0) as total_balance_cents,
    COUNT(DISTINCT la.id) as account_count
  FROM ledger_accounts la
  LEFT JOIN ledger_balance_snapshots lbs ON la.id = lbs.account_id
  GROUP BY la.account_type
  ORDER BY la.account_type;
END;
$function$
"
"public","get_uma_settlement_status","CREATE OR REPLACE FUNCTION public.get_uma_settlement_status(market_id_param uuid)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE
  market_record RECORD;
  result JSON;
BEGIN
  SELECT * INTO market_record FROM markets WHERE id = market_id_param;
  
  IF NOT FOUND THEN
    RETURN json_build_object('error', 'Market not found');
  END IF;
  
  result := json_build_object(
    'market_id', market_id_param,
    'blockchain_status', market_record.blockchain_status,
    'can_request_settlement', (
      market_record.blockchain_status = 'deployed' 
      AND market_record.end_date <= NOW()
    ),
    'can_propose_outcome', (
      market_record.blockchain_status = 'resolution_requested'
      AND market_record.uma_proposal_count < 2
    ),
    'can_finalize_settlement', can_settle_via_uma(market_id_param),
    'proposal_count', market_record.uma_proposal_count,
    'liveness_ends_at', market_record.uma_liveness_ends_at,
    'time_until_settlement', CASE
      WHEN market_record.uma_liveness_ends_at IS NOT NULL THEN
        EXTRACT(EPOCH FROM (market_record.uma_liveness_ends_at - NOW()))
      ELSE NULL
    END
  );
  
  RETURN result;
END;
$function$
"
"public","get_user_ledger_balance","CREATE OR REPLACE FUNCTION public.get_user_ledger_balance(p_user_id uuid)
 RETURNS numeric
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN COALESCE(
        (SELECT (SUM(amount_cents) FILTER (WHERE entry_side = 'debit') -
                 SUM(amount_cents) FILTER (WHERE entry_side = 'credit'))::NUMERIC / 100
         FROM ledger_entries
         WHERE user_id = p_user_id
         AND account_type = 'user'),
        0
    );
END;
$function$
"
"public","get_user_settlement_bonds","CREATE OR REPLACE FUNCTION public.get_user_settlement_bonds(p_user_id uuid)
 RETURNS TABLE(id uuid, type text, market_id uuid, market_title text, amount numeric, status text, potential_payout numeric, created_at timestamp with time zone, resolved_at timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    sb.id,
    'settlement'::TEXT as type,
    sb.market_id,
    m.title as market_title,
    sb.bond_amount as amount,
    CASE 
      WHEN sb.resolved_at IS NULL THEN 'active'
      WHEN sb.won THEN 'won'
      ELSE 'lost'
    END::TEXT as status,
    sb.potential_payout,
    sb.created_at,
    sb.resolved_at
  FROM settlement_bonds sb
  JOIN markets m ON m.id = sb.market_id
  WHERE sb.creator_id = p_user_id
  
  UNION ALL
  
  SELECT 
    sc.id,
    'contest'::TEXT as type,
    sc.market_id,
    m.title as market_title,
    sc.contest_bond as amount,
    CASE 
      WHEN sc.resolved_at IS NULL THEN 'active'
      WHEN sc.contestant_won THEN 'won'
      ELSE 'lost'
    END::TEXT as status,
    sc.potential_payout,
    sc.created_at,
    sc.resolved_at
  FROM settlement_contests sc
  JOIN markets m ON m.id = sc.market_id
  WHERE sc.contestant_id = p_user_id
  
  UNION ALL
  
  SELECT 
    sv.id,
    'verification'::TEXT as type,
    sc.market_id,
    m.title as market_title,
    sv.vote_bond as amount,
    CASE 
      WHEN sv.resolved_at IS NULL THEN 'active'
      WHEN sv.won THEN 'won'
      ELSE 'lost'
    END::TEXT as status,
    sv.potential_payout,
    sv.created_at,
    sv.resolved_at
  FROM settlement_votes sv
  JOIN settlement_contests sc ON sc.id = sv.contest_id
  JOIN markets m ON m.id = sc.market_id
  WHERE sv.voter_id = p_user_id
  
  ORDER BY created_at DESC;
END;
$function$
"
"public","get_user_slippage_tolerance","CREATE OR REPLACE FUNCTION public.get_user_slippage_tolerance(p_user_id uuid)
 RETURNS numeric
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_tolerance NUMERIC;
BEGIN
  SELECT slippage_tolerance INTO v_tolerance
  FROM profiles
  WHERE id = p_user_id;
  
  -- Return default 5% if not found
  RETURN COALESCE(v_tolerance, 5.00);
END;
$function$
"
"public","hmac","CREATE OR REPLACE FUNCTION public.hmac(text, text, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_hmac$function$
"
"public","hmac","CREATE OR REPLACE FUNCTION public.hmac(bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pg_hmac$function$
"
"public","initiate_settlement","CREATE OR REPLACE FUNCTION public.initiate_settlement(p_creator_id uuid, p_market_id uuid, p_outcome boolean)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_creator_fees NUMERIC;
    v_bond_id UUID;
    v_contest_deadline TIMESTAMP WITH TIME ZONE;
    v_market_title TEXT;
    v_participant RECORD;
BEGIN
    -- Read creator_fees_earned from markets table to use as bond amount
    SELECT creator_fees_earned, title INTO v_creator_fees, v_market_title
    FROM markets
    WHERE id = p_market_id
    AND creator_id = p_creator_id;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Market not found or you are not the creator';
    END IF;
    
    -- Default to 0 if no fees earned yet
    v_creator_fees := COALESCE(v_creator_fees, 0);
    
    -- Set contest deadline to 1 hour from now
    v_contest_deadline := NOW() + INTERVAL '1 hour';
    
    -- Insert bond with creator_fees_earned as the bond_amount
    INSERT INTO settlement_bonds (
        market_id,
        creator_id,
        bond_amount,
        outcome_chosen,
        status,
        created_at
    ) VALUES (
        p_market_id,
        p_creator_id,
        v_creator_fees,
        p_outcome,
        'active',
        NOW()
    )
    RETURNING id INTO v_bond_id;
    
    -- Update market settlement_status and status, save deadline and outcome
    UPDATE markets
    SET 
        status = 'suspended',
        settlement_status = 'pending_contest',
        contest_deadline = v_contest_deadline,
        creator_settlement_outcome = p_outcome,
        updated_at = NOW()
    WHERE id = p_market_id;
    
    -- Notify all market participants they can contest
    FOR v_participant IN
        SELECT DISTINCT user_id
        FROM positions
        WHERE market_id = p_market_id
        AND user_id != p_creator_id
    LOOP
        INSERT INTO notifications (
            user_id,
            type,
            title,
            message,
            market_id,
            created_at,
            is_read
        ) VALUES (
            v_participant.user_id,
            'settlement_proposed',
            'Settlement Proposed - Contest Available',
            'The creator has proposed a settlement for ""' || v_market_title || '"". You have until ' || 
            TO_CHAR(v_contest_deadline, 'Mon DD at HH:MI AM') || ' to contest this outcome by posting a $50 bond.',
            p_market_id,
            NOW(),
            false
        );
    END LOOP;
    
    RETURN json_build_object(
        'bond_id', v_bond_id,
        'bond_amount', v_creator_fees,
        'contest_deadline', v_contest_deadline
    );
END;
$function$
"
"public","initiate_settlement_v2","CREATE OR REPLACE FUNCTION public.initiate_settlement_v2(p_creator_id uuid, p_market_id uuid, p_outcome text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_market RECORD;
  v_bond_amount NUMERIC;
  v_outcome_bool BOOLEAN;
  v_bond_id UUID;
BEGIN
  -- Validate outcome
  IF p_outcome NOT IN ('yes', 'no', 'cancel') THEN
    RAISE EXCEPTION 'Invalid outcome. Must be yes, no, or cancel';
  END IF;
  
  -- Convert to boolean for legacy support
  v_outcome_bool := CASE WHEN p_outcome = 'yes' THEN TRUE WHEN p_outcome = 'no' THEN FALSE ELSE NULL END;
  
  -- Get market details
  SELECT * INTO v_market
  FROM markets
  WHERE id = p_market_id;
  
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Market not found';
  END IF;
  
  -- Verify caller is the creator
  IF v_market.creator_id != p_creator_id THEN
    RAISE EXCEPTION 'Only the market creator can initiate settlement';
  END IF;
  
  -- Verify market is private
  IF v_market.is_private != TRUE THEN
    RAISE EXCEPTION 'Settlement can only be initiated for private markets';
  END IF;
  
  -- Verify market is in a valid state
  IF v_market.status NOT IN ('active', 'expired', 'open', 'closed') THEN
    RAISE EXCEPTION 'Market must be open or closed to initiate settlement. Current status: %', v_market.status;
  END IF;
  
  -- Get bond amount from creator_fees_earned (no minimum, can be 0)
  v_bond_amount := COALESCE(v_market.creator_fees_earned, 0);
  
  RAISE NOTICE 'Creating settlement bond for market %, amount: $% (creator_fees_earned)', p_market_id, v_bond_amount;
  
  -- Create settlement bond
  INSERT INTO settlement_bonds (
    market_id,
    creator_id,
    bond_amount,
    outcome_chosen,
    outcome_chosen_text,
    status,
    created_at
  ) VALUES (
    p_market_id,
    p_creator_id,
    v_bond_amount,
    v_outcome_bool,
    p_outcome,
    'active',
    NOW()
  )
  RETURNING id INTO v_bond_id;
  
  -- Fixed: Now properly setting creator_settlement_outcome and creator_settlement_outcome_text
  UPDATE markets
  SET 
    status = 'suspended',
    settlement_status = 'pending_contest',
    -- Set creator outcome columns so UI can read them
    creator_settlement_outcome = v_outcome_bool,
    creator_settlement_outcome_text = p_outcome,
    outcome_text = p_outcome,
    contest_deadline = NOW() + INTERVAL '1 hour',
    updated_at = NOW()
  WHERE id = p_market_id;
  
  -- Notify creator
  INSERT INTO notifications (user_id, type, title, message, market_id)
  VALUES (
    p_creator_id,
    'settlement_bond_posted',
    'Settlement Bond Posted',
    'You have proposed settling ""' || v_market.title || '"" as ' || UPPER(p_outcome) || '. Bond amount: $' || v_bond_amount || '. Contest period: 1 hour.',
    p_market_id
  );
  
  -- Notify all users with positions
  INSERT INTO notifications (user_id, type, title, message, market_id)
  SELECT DISTINCT 
    p.user_id,
    'settlement',
    'Settlement Proposed',
    'The creator of ""' || v_market.title || '"" has proposed settling the market as ' || UPPER(p_outcome) || '. You have 1 hour to contest.',
    p_market_id
  FROM positions p
  WHERE p.market_id = p_market_id
    AND p.user_id != p_creator_id
    AND (p.shares > 0 OR p.shares < 0);
  
  RETURN jsonb_build_object(
    'success', true,
    'bond_id', v_bond_id,
    'bond_amount', v_bond_amount,
    'creator_fees_earned', v_market.creator_fees_earned,
    'contest_deadline', NOW() + INTERVAL '1 hour'
  );
END;
$function$
"
"public","normalize_transaction_side","CREATE OR REPLACE FUNCTION public.normalize_transaction_side()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Automatically convert side to uppercase before insert/update
    IF NEW.side IS NOT NULL THEN
        NEW.side := UPPER(NEW.side);
    END IF;
    RETURN NEW;
END;
$function$
"
"public","notify_contest_bond_created","CREATE OR REPLACE FUNCTION public.notify_contest_bond_created()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_market_title TEXT;
BEGIN
  -- Get market title
  SELECT title INTO v_market_title
  FROM markets
  WHERE id = NEW.market_id;

  -- Added title column to notification insert
  INSERT INTO notifications (
    user_id,
    market_id,
    type,
    title,
    message,
    created_at,
    is_read
  )
  VALUES (
    NEW.contestant_id,
    NEW.market_id,
    'contest_bond_posted',
    'Contest Bond Posted',
    format('Contest bond posted for ""%s"". Amount: $%s. Voting period active for 1 hour.',
      v_market_title,
      ROUND(NEW.contest_bond_amount, 2)
    ),
    NOW(),
    FALSE
  );

  RETURN NEW;
END;
$function$
"
"public","notify_settlement_bond_created","CREATE OR REPLACE FUNCTION public.notify_settlement_bond_created()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_market_title TEXT;
BEGIN
  -- Get market title
  SELECT title INTO v_market_title
  FROM markets
  WHERE id = NEW.market_id;

  -- Added title column to notification insert
  INSERT INTO notifications (
    user_id,
    market_id,
    type,
    title,
    message,
    created_at,
    is_read
  )
  VALUES (
    NEW.creator_id,
    NEW.market_id,
    'settlement_bond_posted',
    'Settlement Bond Posted',
    format('Settlement bond posted for ""%s"". Amount: $%s. Contest period active for 1 hour.',
      v_market_title,
      ROUND(NEW.bond_amount, 2)
    ),
    NOW(),
    FALSE
  );

  RETURN NEW;
END;
$function$
"
"public","notify_vote_bond_created","CREATE OR REPLACE FUNCTION public.notify_vote_bond_created()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_market_title TEXT;
  v_market_id UUID;
BEGIN
  -- Get market ID and title from contest
  SELECT sc.market_id, m.title
  INTO v_market_id, v_market_title
  FROM settlement_contests sc
  JOIN markets m ON m.id = sc.market_id
  WHERE sc.id = NEW.contest_id;

  -- Added title column to notification insert
  INSERT INTO notifications (
    user_id,
    market_id,
    type,
    title,
    message,
    created_at,
    is_read
  )
  VALUES (
    NEW.voter_id,
    v_market_id,
    'vote_bond_posted',
    'Vote Bond Posted',
    format('Vote bond posted for ""%s"". Amount: $%s. Your vote has been recorded.',
      v_market_title,
      ROUND(NEW.vote_bond_amount, 2)
    ),
    NOW(),
    FALSE
  );

  RETURN NEW;
END;
$function$
"
"public","outcome_bool_to_text","CREATE OR REPLACE FUNCTION public.outcome_bool_to_text(p_outcome boolean)
 RETURNS text
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
BEGIN
    IF p_outcome = true THEN
        RETURN 'yes';
    ELSIF p_outcome = false THEN
        RETURN 'no';
    ELSE
        RETURN NULL;
    END IF;
END;
$function$
"
"public","outcome_text_to_bool","CREATE OR REPLACE FUNCTION public.outcome_text_to_bool(p_outcome text)
 RETURNS boolean
 LANGUAGE plpgsql
 IMMUTABLE
AS $function$
BEGIN
    IF p_outcome = 'yes' THEN
        RETURN true;
    ELSIF p_outcome = 'no' THEN
        RETURN false;
    ELSIF p_outcome = 'cancel' THEN
        RETURN NULL; -- Cancel returns NULL for boolean
    ELSE
        RETURN NULL;
    END IF;
END;
$function$
"
"public","payout_bonds_to_ledger","CREATE OR REPLACE FUNCTION public.payout_bonds_to_ledger(p_market_id uuid, p_winning_side text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_proposal_bond RECORD;
    v_contest RECORD;
    v_vote RECORD;
    v_group_id UUID := gen_random_uuid();
    v_amount_cents BIGINT;
    v_proposal_bond_account_id UUID;
    v_contest_bond_account_id UUID;
    v_vote_bond_account_id UUID;
    v_user_account_id UUID;
    v_distribution_account_id UUID;
    v_total_losing_pool NUMERIC := 0;
    v_total_winning_stake NUMERIC := 0;
    v_bonus_per_dollar NUMERIC := 0;
    v_payout NUMERIC;
    v_bonus NUMERIC;
BEGIN
    -- Get the settlement bond (proposer)
    SELECT sb.*, p.id as proposer_id
    INTO v_proposal_bond
    FROM settlement_bonds sb
    JOIN profiles p ON p.id = sb.creator_id
    WHERE sb.market_id = p_market_id
    AND sb.status IN ('active', 'resolved', 'won', 'lost', 'returned')
    LIMIT 1;
    
    -- Get the contest if exists
    SELECT sc.*, p.id as contestant_id
    INTO v_contest
    FROM settlement_contests sc
    JOIN profiles p ON p.id = sc.contestant_id
    WHERE sc.market_id = p_market_id
    AND sc.status IN ('active', 'voting', 'resolved')
    LIMIT 1;
    
    -- Get/create accounts
    v_proposal_bond_account_id := get_or_create_account(p_market_id, 'proposal_bond');
    v_distribution_account_id := get_or_create_account(p_market_id, 'bond_distribution');
    
    IF v_contest.id IS NOT NULL THEN
        v_contest_bond_account_id := get_or_create_account(p_market_id, 'contest_bond');
        v_vote_bond_account_id := get_or_create_account(p_market_id, 'vote_bond');
    END IF;
    
    -- Calculate losing pool and winning stake based on outcome
    IF p_winning_side = 'proposal' THEN
        v_total_losing_pool := COALESCE(v_contest.contest_bond_amount, 0);
        SELECT COALESCE(SUM(vote_bond_amount), 0) INTO v_bonus
        FROM settlement_votes WHERE contest_id = v_contest.id AND is_correct = false;
        v_total_losing_pool := v_total_losing_pool + v_bonus;
        
        v_total_winning_stake := COALESCE(v_proposal_bond.bond_amount, 0);
        SELECT COALESCE(SUM(vote_bond_amount), 0) INTO v_bonus
        FROM settlement_votes WHERE contest_id = v_contest.id AND is_correct = true;
        v_total_winning_stake := v_total_winning_stake + v_bonus;
        
    ELSIF p_winning_side = 'contest' THEN
        v_total_losing_pool := COALESCE(v_proposal_bond.bond_amount, 0);
        SELECT COALESCE(SUM(vote_bond_amount), 0) INTO v_bonus
        FROM settlement_votes WHERE contest_id = v_contest.id AND is_correct = false;
        v_total_losing_pool := v_total_losing_pool + v_bonus;
        
        v_total_winning_stake := COALESCE(v_contest.contest_bond_amount, 0);
        SELECT COALESCE(SUM(vote_bond_amount), 0) INTO v_bonus
        FROM settlement_votes WHERE contest_id = v_contest.id AND is_correct = true;
        v_total_winning_stake := v_total_winning_stake + v_bonus;
        
    ELSE -- 'cancel'
        v_total_losing_pool := COALESCE(v_proposal_bond.bond_amount, 0) + COALESCE(v_contest.contest_bond_amount, 0);
        SELECT COALESCE(SUM(vote_bond_amount), 0) INTO v_bonus
        FROM settlement_votes WHERE contest_id = v_contest.id AND is_correct = false;
        v_total_losing_pool := v_total_losing_pool + v_bonus;
        
        SELECT COALESCE(SUM(vote_bond_amount), 0) INTO v_total_winning_stake
        FROM settlement_votes WHERE contest_id = v_contest.id AND is_correct = true;
    END IF;
    
    IF v_total_winning_stake > 0 THEN
        v_bonus_per_dollar := v_total_losing_pool / v_total_winning_stake;
    END IF;
    
    -- ============================================
    -- LEDGER ENTRIES: First credit all losing bonds to distribution pool
    -- ============================================
    
    -- Proposer loses -> credit to distribution pool
    IF v_proposal_bond.id IS NOT NULL AND p_winning_side != 'proposal' THEN
        v_amount_cents := ROUND(v_proposal_bond.bond_amount * 100)::BIGINT;
        IF v_amount_cents > 0 THEN
            PERFORM create_ledger_entry(
                v_proposal_bond_account_id, v_proposal_bond.proposer_id, 'debit', v_amount_cents,
                'bond_forfeited', NULL, p_market_id, 'proposal_bond', v_group_id,
                'Proposal bond forfeited', jsonb_build_object('market_id', p_market_id)
            );
            PERFORM create_ledger_entry(
                v_distribution_account_id, v_proposal_bond.proposer_id, 'credit', v_amount_cents,
                'bond_to_pool', NULL, p_market_id, 'bond_distribution', v_group_id,
                'Bond added to distribution pool', jsonb_build_object('source', 'proposal')
            );
        END IF;
    END IF;
    
    -- Contestant loses -> credit to distribution pool
    IF v_contest.id IS NOT NULL AND p_winning_side != 'contest' THEN
        v_amount_cents := ROUND(v_contest.contest_bond_amount * 100)::BIGINT;
        IF v_amount_cents > 0 THEN
            PERFORM create_ledger_entry(
                v_contest_bond_account_id, v_contest.contestant_id, 'debit', v_amount_cents,
                'bond_forfeited', NULL, p_market_id, 'contest_bond', v_group_id,
                'Contest bond forfeited', jsonb_build_object('market_id', p_market_id)
            );
            PERFORM create_ledger_entry(
                v_distribution_account_id, v_contest.contestant_id, 'credit', v_amount_cents,
                'bond_to_pool', NULL, p_market_id, 'bond_distribution', v_group_id,
                'Bond added to distribution pool', jsonb_build_object('source', 'contest')
            );
        END IF;
    END IF;
    
    -- Losing voters -> credit to distribution pool
    IF v_contest.id IS NOT NULL THEN
        FOR v_vote IN
            SELECT sv.*, p.id as voter_id
            FROM settlement_votes sv
            JOIN profiles p ON p.id = sv.voter_id
            WHERE sv.contest_id = v_contest.id AND sv.is_correct = false
        LOOP
            v_amount_cents := ROUND(v_vote.vote_bond_amount * 100)::BIGINT;
            IF v_amount_cents > 0 THEN
                PERFORM create_ledger_entry(
                    v_vote_bond_account_id, v_vote.voter_id, 'debit', v_amount_cents,
                    'bond_forfeited', NULL, p_market_id, 'vote_bond', v_group_id,
                    'Vote bond forfeited', jsonb_build_object('market_id', p_market_id)
                );
                PERFORM create_ledger_entry(
                    v_distribution_account_id, v_vote.voter_id, 'credit', v_amount_cents,
                    'bond_to_pool', NULL, p_market_id, 'bond_distribution', v_group_id,
                    'Bond added to distribution pool', jsonb_build_object('source', 'vote')
                );
            END IF;
        END LOOP;
    END IF;
    
    -- ============================================
    -- LEDGER ENTRIES: Debit distribution pool to pay winners
    -- ============================================
    
    -- Proposer wins
    IF v_proposal_bond.id IS NOT NULL AND p_winning_side = 'proposal' THEN
        v_user_account_id := get_or_create_account(v_proposal_bond.proposer_id, 'user');
        v_bonus := ROUND(v_proposal_bond.bond_amount * v_bonus_per_dollar, 2);
        v_payout := ROUND(v_proposal_bond.bond_amount + v_bonus, 2);
        
        -- Return original bond from bond account
        v_amount_cents := ROUND(v_proposal_bond.bond_amount * 100)::BIGINT;
        IF v_amount_cents > 0 THEN
            PERFORM create_ledger_entry(
                v_proposal_bond_account_id, v_proposal_bond.proposer_id, 'debit', v_amount_cents,
                'bond_return', NULL, p_market_id, 'proposal_bond', v_group_id,
                'Proposal bond returned', jsonb_build_object('market_id', p_market_id)
            );
            PERFORM create_ledger_entry(
                v_user_account_id, v_proposal_bond.proposer_id, 'credit', v_amount_cents,
                'bond_return', NULL, p_market_id, 'user', v_group_id,
                'Bond returned to user', jsonb_build_object('type', 'proposal_bond')
            );
        END IF;
        
        -- Bonus from distribution pool
        IF v_bonus > 0 THEN
            v_amount_cents := ROUND(v_bonus * 100)::BIGINT;
            PERFORM create_ledger_entry(
                v_distribution_account_id, v_proposal_bond.proposer_id, 'debit', v_amount_cents,
                'bonus_payout', NULL, p_market_id, 'bond_distribution', v_group_id,
                'Bonus from distribution pool', jsonb_build_object('winner', 'proposer')
            );
            PERFORM create_ledger_entry(
                v_user_account_id, v_proposal_bond.proposer_id, 'credit', v_amount_cents,
                'bonus_payout', NULL, p_market_id, 'user', v_group_id,
                'Bonus credited to user', jsonb_build_object('type', 'proposal_bonus')
            );
        END IF;
    END IF;
    
    -- Contestant wins
    IF v_contest.id IS NOT NULL AND p_winning_side = 'contest' THEN
        v_user_account_id := get_or_create_account(v_contest.contestant_id, 'user');
        v_bonus := ROUND(v_contest.contest_bond_amount * v_bonus_per_dollar, 2);
        v_payout := ROUND(v_contest.contest_bond_amount + v_bonus, 2);
        
        -- Return original bond from bond account
        v_amount_cents := ROUND(v_contest.contest_bond_amount * 100)::BIGINT;
        IF v_amount_cents > 0 THEN
            PERFORM create_ledger_entry(
                v_contest_bond_account_id, v_contest.contestant_id, 'debit', v_amount_cents,
                'bond_return', NULL, p_market_id, 'contest_bond', v_group_id,
                'Contest bond returned', jsonb_build_object('market_id', p_market_id)
            );
            PERFORM create_ledger_entry(
                v_user_account_id, v_contest.contestant_id, 'credit', v_amount_cents,
                'bond_return', NULL, p_market_id, 'user', v_group_id,
                'Bond returned to user', jsonb_build_object('type', 'contest_bond')
            );
        END IF;
        
        -- Bonus from distribution pool
        IF v_bonus > 0 THEN
            v_amount_cents := ROUND(v_bonus * 100)::BIGINT;
            PERFORM create_ledger_entry(
                v_distribution_account_id, v_contest.contestant_id, 'debit', v_amount_cents,
                'bonus_payout', NULL, p_market_id, 'bond_distribution', v_group_id,
                'Bonus from distribution pool', jsonb_build_object('winner', 'contestant')
            );
            PERFORM create_ledger_entry(
                v_user_account_id, v_contest.contestant_id, 'credit', v_amount_cents,
                'bonus_payout', NULL, p_market_id, 'user', v_group_id,
                'Bonus credited to user', jsonb_build_object('type', 'contest_bonus')
            );
        END IF;
    END IF;
    
    -- Winning voters
    IF v_contest.id IS NOT NULL THEN
        FOR v_vote IN
            SELECT sv.*, p.id as voter_id
            FROM settlement_votes sv
            JOIN profiles p ON p.id = sv.voter_id
            WHERE sv.contest_id = v_contest.id AND sv.is_correct = true
        LOOP
            v_user_account_id := get_or_create_account(v_vote.voter_id, 'user');
            v_bonus := ROUND(v_vote.vote_bond_amount * v_bonus_per_dollar, 2);
            v_payout := ROUND(v_vote.vote_bond_amount + v_bonus, 2);
            
            -- Return original bond from bond account
            v_amount_cents := ROUND(v_vote.vote_bond_amount * 100)::BIGINT;
            IF v_amount_cents > 0 THEN
                PERFORM create_ledger_entry(
                    v_vote_bond_account_id, v_vote.voter_id, 'debit', v_amount_cents,
                    'bond_return', NULL, p_market_id, 'vote_bond', v_group_id,
                    'Vote bond returned', jsonb_build_object('market_id', p_market_id)
                );
                PERFORM create_ledger_entry(
                    v_user_account_id, v_vote.voter_id, 'credit', v_amount_cents,
                    'bond_return', NULL, p_market_id, 'user', v_group_id,
                    'Bond returned to user', jsonb_build_object('type', 'vote_bond')
                );
            END IF;
            
            -- Bonus from distribution pool
            IF v_bonus > 0 THEN
                v_amount_cents := ROUND(v_bonus * 100)::BIGINT;
                PERFORM create_ledger_entry(
                    v_distribution_account_id, v_vote.voter_id, 'debit', v_amount_cents,
                    'bonus_payout', NULL, p_market_id, 'bond_distribution', v_group_id,
                    'Bonus from distribution pool', jsonb_build_object('winner', 'voter')
                );
                PERFORM create_ledger_entry(
                    v_user_account_id, v_vote.voter_id, 'credit', v_amount_cents,
                    'bonus_payout', NULL, p_market_id, 'user', v_group_id,
                    'Bonus credited to user', jsonb_build_object('type', 'vote_bonus')
                );
            END IF;
        END LOOP;
    END IF;
END;
$function$
"
"public","pgp_armor_headers","CREATE OR REPLACE FUNCTION public.pgp_armor_headers(text, OUT key text, OUT value text)
 RETURNS SETOF record
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_armor_headers$function$
"
"public","pgp_key_id","CREATE OR REPLACE FUNCTION public.pgp_key_id(bytea)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_key_id_w$function$
"
"public","pgp_pub_decrypt","CREATE OR REPLACE FUNCTION public.pgp_pub_decrypt(bytea, bytea, text, text)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$
"
"public","pgp_pub_decrypt","CREATE OR REPLACE FUNCTION public.pgp_pub_decrypt(bytea, bytea)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$
"
"public","pgp_pub_decrypt","CREATE OR REPLACE FUNCTION public.pgp_pub_decrypt(bytea, bytea, text)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_text$function$
"
"public","pgp_pub_decrypt_bytea","CREATE OR REPLACE FUNCTION public.pgp_pub_decrypt_bytea(bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$
"
"public","pgp_pub_decrypt_bytea","CREATE OR REPLACE FUNCTION public.pgp_pub_decrypt_bytea(bytea, bytea)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$
"
"public","pgp_pub_decrypt_bytea","CREATE OR REPLACE FUNCTION public.pgp_pub_decrypt_bytea(bytea, bytea, text, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_decrypt_bytea$function$
"
"public","pgp_pub_encrypt","CREATE OR REPLACE FUNCTION public.pgp_pub_encrypt(text, bytea, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$
"
"public","pgp_pub_encrypt","CREATE OR REPLACE FUNCTION public.pgp_pub_encrypt(text, bytea)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_text$function$
"
"public","pgp_pub_encrypt_bytea","CREATE OR REPLACE FUNCTION public.pgp_pub_encrypt_bytea(bytea, bytea)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$
"
"public","pgp_pub_encrypt_bytea","CREATE OR REPLACE FUNCTION public.pgp_pub_encrypt_bytea(bytea, bytea, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_pub_encrypt_bytea$function$
"
"public","pgp_sym_decrypt","CREATE OR REPLACE FUNCTION public.pgp_sym_decrypt(bytea, text)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$
"
"public","pgp_sym_decrypt","CREATE OR REPLACE FUNCTION public.pgp_sym_decrypt(bytea, text, text)
 RETURNS text
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_text$function$
"
"public","pgp_sym_decrypt_bytea","CREATE OR REPLACE FUNCTION public.pgp_sym_decrypt_bytea(bytea, text, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$
"
"public","pgp_sym_decrypt_bytea","CREATE OR REPLACE FUNCTION public.pgp_sym_decrypt_bytea(bytea, text)
 RETURNS bytea
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_decrypt_bytea$function$
"
"public","pgp_sym_encrypt","CREATE OR REPLACE FUNCTION public.pgp_sym_encrypt(text, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$
"
"public","pgp_sym_encrypt","CREATE OR REPLACE FUNCTION public.pgp_sym_encrypt(text, text, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_text$function$
"
"public","pgp_sym_encrypt_bytea","CREATE OR REPLACE FUNCTION public.pgp_sym_encrypt_bytea(bytea, text, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$
"
"public","pgp_sym_encrypt_bytea","CREATE OR REPLACE FUNCTION public.pgp_sym_encrypt_bytea(bytea, text)
 RETURNS bytea
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/pgcrypto', $function$pgp_sym_encrypt_bytea$function$
"
"public","reconcile_ledger_snapshots","CREATE OR REPLACE FUNCTION public.reconcile_ledger_snapshots()
 RETURNS TABLE(account_id uuid, account_type text, snapshot_balance_cents bigint, ledger_balance_cents bigint, difference_cents bigint, is_reconciled boolean)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  WITH ledger_balances AS (
    SELECT 
      le.account_id,
      SUM(CASE WHEN le.entry_side = 'credit' THEN le.amount_cents 
               WHEN le.entry_side = 'debit' THEN -le.amount_cents
               ELSE 0 END) as calculated_balance_cents
    FROM ledger_entries le
    WHERE le.account_id IS NOT NULL
    GROUP BY le.account_id
  )
  SELECT 
    la.id as account_id,
    la.account_type,
    COALESCE(lbs.balance_cents, 0) as snapshot_balance_cents,
    COALESCE(lb.calculated_balance_cents, 0) as ledger_balance_cents,
    COALESCE(lbs.balance_cents, 0) - COALESCE(lb.calculated_balance_cents, 0) as difference_cents,
    COALESCE(lbs.balance_cents, 0) = COALESCE(lb.calculated_balance_cents, 0) as is_reconciled
  FROM ledger_accounts la
  LEFT JOIN ledger_balance_snapshots lbs ON la.id = lbs.account_id
  LEFT JOIN ledger_balances lb ON la.id = lb.account_id
  WHERE COALESCE(lbs.balance_cents, 0) != COALESCE(lb.calculated_balance_cents, 0);
END;
$function$
"
"public","record_price_snapshot","CREATE OR REPLACE FUNCTION public.record_price_snapshot()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  market_data RECORD;
  yes_prob NUMERIC;
  no_prob NUMERIC;
  last_snapshot_time TIMESTAMP;
BEGIN
  -- Now handles 'buy' and 'sell' instead of just 'bet'
  IF NEW.type NOT IN ('buy', 'sell', 'BUY', 'SELL', 'bet') THEN
    RETURN NEW;
  END IF;

  -- Check when the last price snapshot was recorded for this market
  SELECT MAX(created_at) INTO last_snapshot_time
  FROM market_price_history
  WHERE market_id = NEW.market_id;
  
  -- Skip if a snapshot was recorded less than 1 minute ago (rate limiting)
  IF last_snapshot_time IS NOT NULL AND 
     EXTRACT(EPOCH FROM (NOW() - last_snapshot_time)) < 60 THEN
    RETURN NEW;
  END IF;

  -- Get current market state AFTER the trade
  SELECT qy, qn, b, total_volume INTO market_data
  FROM markets
  WHERE id = NEW.market_id;
  
  -- Skip if market not found
  IF market_data IS NULL THEN
    RETURN NEW;
  END IF;
  
  -- Calculate probabilities using LMSR formula with POST-TRADE values
  -- P(YES) = exp(qy/b) / (exp(qy/b) + exp(qn/b))
  yes_prob := EXP(market_data.qy / market_data.b) / 
              (EXP(market_data.qy / market_data.b) + EXP(market_data.qn / market_data.b));
  no_prob := 1 - yes_prob;
  
  -- Insert snapshot
  INSERT INTO market_price_history (
    market_id,
    yes_probability,
    no_probability,
    qy,
    qn,
    total_volume
  ) VALUES (
    NEW.market_id,
    yes_prob,
    no_prob,
    market_data.qy,
    market_data.qn,
    COALESCE(market_data.total_volume, 0)
  );
  
  RETURN NEW;
END;
$function$
"
"public","resolve_contested_settlement","CREATE OR REPLACE FUNCTION public.resolve_contested_settlement(p_contest_id uuid)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_market_id UUID;
  v_initiator_outcome BOOLEAN;
  v_contestant_outcome BOOLEAN;
  v_initiator_votes INTEGER := 1; -- Initiator counts as 1 vote
  v_contestant_votes INTEGER := 1; -- Contestant counts as 1 vote
  v_total_votes INTEGER;
  v_winning_outcome BOOLEAN;
  v_is_tie BOOLEAN;
BEGIN
  RAISE NOTICE '[v0] resolve_contested_settlement: Starting for contest %', p_contest_id;
  
  -- Get contest details
  SELECT 
    sc.market_id,
    m.creator_settlement_outcome,
    sc.contestant_outcome
  INTO v_market_id, v_initiator_outcome, v_contestant_outcome
  FROM settlement_contests sc
  JOIN markets m ON m.id = sc.market_id
  WHERE sc.id = p_contest_id;
  
  IF v_market_id IS NULL THEN
    RAISE NOTICE '[v0] Contest not found: %', p_contest_id;
    RETURN json_build_object('success', false, 'error', 'Contest not found');
  END IF;
  
  RAISE NOTICE '[v0] Contest details - Market: %, Initiator outcome: %, Contestant outcome: %',
    v_market_id, v_initiator_outcome, v_contestant_outcome;
  
  -- Count additional votes from settlement_votes table
  -- Votes for initiator's outcome
  SELECT COUNT(*) INTO v_initiator_votes
  FROM settlement_votes
  WHERE contest_id = p_contest_id
    AND vote = v_initiator_outcome;
  
  -- Add 1 for the initiator's implicit vote
  v_initiator_votes := v_initiator_votes + 1;
  
  -- Votes for contestant's outcome  
  SELECT COUNT(*) INTO v_contestant_votes
  FROM settlement_votes
  WHERE contest_id = p_contest_id
    AND vote = v_contestant_outcome;
  
  -- Add 1 for the contestant's implicit vote
  v_contestant_votes := v_contestant_votes + 1;
  
  v_total_votes := v_initiator_votes + v_contestant_votes;
  
  RAISE NOTICE '[v0] Vote count - Initiator: %, Contestant: %, Total: %',
    v_initiator_votes, v_contestant_votes, v_total_votes;
  
  -- Determine winner (majority wins, tie = cancel)
  IF v_initiator_votes > v_contestant_votes THEN
    v_winning_outcome := v_initiator_outcome;
    v_is_tie := false;
    RAISE NOTICE '[v0] Initiator wins with outcome: %', v_winning_outcome;
  ELSIF v_contestant_votes > v_initiator_votes THEN
    v_winning_outcome := v_contestant_outcome;
    v_is_tie := false;
    RAISE NOTICE '[v0] Contestant wins with outcome: %', v_winning_outcome;
  ELSE
    v_is_tie := true;
    RAISE NOTICE '[v0] Vote is tied - cancelling market';
  END IF;
  
  IF v_is_tie THEN
    -- Cancel market and refund everyone
    UPDATE markets
    SET 
      status = 'cancelled',
      settlement_status = 'resolved'
    WHERE id = v_market_id;
    
    UPDATE settlement_contests
    SET 
      status = 'tie',
      resolved_at = NOW()
    WHERE id = p_contest_id;
    
    -- Return all bonds
    UPDATE settlement_bonds
    SET 
      status = 'returned',
      returned_at = NOW()
    WHERE market_id = v_market_id;
    
    RAISE NOTICE '[v0] Market cancelled due to tie';
    
    RETURN json_build_object(
      'success', true,
      'result', 'tie',
      'market_cancelled', true
    );
  ELSE
    -- Settle market with winning outcome
    UPDATE markets
    SET 
      status = 'settled',
      settlement_status = 'resolved',
      outcome = v_winning_outcome,
      winning_side = v_winning_outcome,
      settled_at = NOW()
    WHERE id = v_market_id;
    
    UPDATE settlement_contests
    SET 
      status = 'resolved',
      resolved_at = NOW(),
      winning_outcome = v_winning_outcome
    WHERE id = p_contest_id;
    
    -- Return bonds to winners, forfeit from losers
    UPDATE settlement_bonds
    SET 
      status = CASE 
        WHEN (SELECT creator_settlement_outcome FROM markets WHERE id = v_market_id) = v_winning_outcome 
        THEN 'returned'
        ELSE 'forfeited'
      END,
      returned_at = CASE 
        WHEN (SELECT creator_settlement_outcome FROM markets WHERE id = v_market_id) = v_winning_outcome 
        THEN NOW()
        ELSE NULL
      END
    WHERE market_id = v_market_id;
    
    RAISE NOTICE '[v0] Market settled with outcome: %', v_winning_outcome;
    
    RETURN json_build_object(
      'success', true,
      'result', 'resolved',
      'winning_outcome', v_winning_outcome
    );
  END IF;
  
EXCEPTION WHEN OTHERS THEN
  RAISE NOTICE '[v0] resolve_contested_settlement ERROR: %', SQLERRM;
  RETURN json_build_object(
    'success', false,
    'error', SQLERRM
  );
END;
$function$
"
"public","run_audit_summary","CREATE OR REPLACE FUNCTION public.run_audit_summary()
 RETURNS TABLE(positions_mismatches integer, market_qy_mismatches integer, market_qn_mismatches integer, liquidity_mismatches integer, total_issues integer, status text)
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_pos_count INTEGER;
  v_qy_count INTEGER;
  v_qn_count INTEGER;
  v_lp_count INTEGER;
BEGIN
  -- Count position mismatches
  SELECT COUNT(*) INTO v_pos_count FROM run_positions_audit();
  
  -- Count market qy/qn mismatches
  SELECT COUNT(*) FILTER (WHERE qy_mismatch), COUNT(*) FILTER (WHERE qn_mismatch)
  INTO v_qy_count, v_qn_count
  FROM run_market_shares_audit();
  
  -- Count liquidity mismatches
  SELECT COUNT(*) INTO v_lp_count FROM run_liquidity_audit() WHERE lp_mismatch;
  
  RETURN QUERY SELECT 
    v_pos_count,
    v_qy_count,
    v_qn_count,
    v_lp_count,
    v_pos_count + v_qy_count + v_qn_count + v_lp_count,
    CASE WHEN v_pos_count + v_qy_count + v_qn_count + v_lp_count = 0 
         THEN 'PASS' 
         ELSE 'FAIL' 
    END;
END;
$function$
"
"public","run_balance_reconciliation","CREATE OR REPLACE FUNCTION public.run_balance_reconciliation()
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_user_discrepancies JSONB;
  v_summary JSONB;
  v_user_issues_count INTEGER := 0;
BEGIN
  -- Validate user balances against ledger_balance_snapshots
  WITH ledger_balances AS (
    SELECT 
      la.reference_id as user_id,
      COALESCE(lbs.balance_cents, 0) / 100.0 as computed_balance
    FROM ledger_accounts la
    LEFT JOIN ledger_balance_snapshots lbs ON la.id = lbs.account_id
    WHERE la.account_type = 'user'
  ),
  balance_comparison AS (
    SELECT 
      p.id as user_id,
      p.username,
      p.balance as stored_balance,
      COALESCE(lb.computed_balance, 0) as ledger_balance,
      ABS(p.balance - COALESCE(lb.computed_balance, 0)) as discrepancy
    FROM profiles p
    LEFT JOIN ledger_balances lb ON p.id = lb.user_id
    WHERE ABS(p.balance - COALESCE(lb.computed_balance, 0)) > 0.01
  )
  SELECT 
    jsonb_agg(
      jsonb_build_object(
        'user_id', user_id,
        'username', username,
        'stored_balance', stored_balance,
        'ledger_balance', ledger_balance,
        'discrepancy', discrepancy
      )
    ),
    COUNT(*)
  INTO v_user_discrepancies, v_user_issues_count
  FROM balance_comparison;

  -- Build summary (no market issues anymore)
  v_summary := jsonb_build_object(
    'timestamp', NOW(),
    'user_balance_issues', v_user_issues_count,
    'total_issues', v_user_issues_count,
    'status', CASE 
      WHEN v_user_issues_count = 0 THEN 'PASS'
      ELSE 'ISSUES_FOUND'
    END
  );

  -- Return complete report (only user discrepancies now)
  RETURN jsonb_build_object(
    'summary', v_summary,
    'user_discrepancies', COALESCE(v_user_discrepancies, '[]'::jsonb)
  );
END;
$function$
"
"public","run_liquidity_audit","CREATE OR REPLACE FUNCTION public.run_liquidity_audit()
 RETURNS TABLE(market_id uuid, market_title text, lp_markets numeric, lp_ledger numeric, lp_transactions numeric, lp_mismatch boolean)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  WITH txn_lp AS (
    -- Get latest market_liquidity_pool from transactions table (set by trigger)
    SELECT DISTINCT ON (t.market_id)
      t.market_id,
      ROUND(COALESCE(t.market_liquidity_pool, 0)::NUMERIC, 4) as txn_lp_balance
    FROM transactions t
    WHERE t.market_id IS NOT NULL
    ORDER BY t.market_id, t.created_at DESC
  ),
  ledger_lp AS (
    SELECT 
      la.reference_id as market_id,
      ROUND(COALESCE(lbs.balance_cents, 0)::NUMERIC / 100, 4) as ledger_balance
    FROM ledger_accounts la
    LEFT JOIN ledger_balance_snapshots lbs ON la.id = lbs.account_id
    WHERE la.account_type = 'market_pool'
  )
  SELECT 
    m.id as market_id,
    LEFT(m.title, 30) as market_title,
    ROUND(COALESCE(m.liquidity_pool, 0)::NUMERIC, 4) as lp_markets,
    ROUND(COALESCE(ll.ledger_balance, 0)::NUMERIC, 4) as lp_ledger,
    ROUND(COALESCE(tl.txn_lp_balance, 0)::NUMERIC, 4) as lp_transactions,
    (ABS(COALESCE(m.liquidity_pool, 0) - COALESCE(ll.ledger_balance, 0)) > 0.01 OR
     ABS(COALESCE(m.liquidity_pool, 0) - COALESCE(tl.txn_lp_balance, 0)) > 0.01) as lp_mismatch
  FROM markets m
  LEFT JOIN txn_lp tl ON m.id = tl.market_id
  LEFT JOIN ledger_lp ll ON m.id = ll.market_id
  WHERE m.status = 'active'
  ORDER BY m.title;
END;
$function$
"
"public","run_market_shares_audit","CREATE OR REPLACE FUNCTION public.run_market_shares_audit()
 RETURNS TABLE(market_id uuid, market_title text, qy_markets numeric, qy_transactions numeric, qy_ledger numeric, qn_markets numeric, qn_transactions numeric, qn_ledger numeric, qy_mismatch boolean, qn_mismatch boolean)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  WITH txn_shares AS (
    SELECT 
      t.market_id,
      ROUND(SUM(CASE WHEN t.side = 'YES' AND t.type = 'buy' THEN t.shares ELSE 0 END)::NUMERIC, 4) -
      ROUND(SUM(CASE WHEN t.side = 'YES' AND t.type = 'sell' THEN t.shares ELSE 0 END)::NUMERIC, 4) as txn_qy,
      ROUND(SUM(CASE WHEN t.side = 'NO' AND t.type = 'buy' THEN t.shares ELSE 0 END)::NUMERIC, 4) -
      ROUND(SUM(CASE WHEN t.side = 'NO' AND t.type = 'sell' THEN t.shares ELSE 0 END)::NUMERIC, 4) as txn_qn
    FROM transactions t
    WHERE t.type IN ('buy', 'sell')
    GROUP BY t.market_id
  ),
  ledger_shares AS (
    SELECT 
      sl.market_id,
      -- Negate ledger values: debit in market account = shares issued (positive in markets table)
      ROUND(SUM(CASE WHEN sl.side = true THEN (sl.debit - sl.credit) ELSE 0 END)::NUMERIC, 4) as ledger_qy,
      ROUND(SUM(CASE WHEN sl.side = false THEN (sl.debit - sl.credit) ELSE 0 END)::NUMERIC, 4) as ledger_qn
    FROM shares_ledger sl
    WHERE sl.account_type = 'market'
    GROUP BY sl.market_id
  )
  SELECT 
    m.id as market_id,
    LEFT(m.title, 30) as market_title,
    ROUND(COALESCE(m.qy, 0)::NUMERIC, 4) as qy_markets,
    ROUND(COALESCE(ts.txn_qy, 0)::NUMERIC, 4) as qy_transactions,
    ROUND(COALESCE(ls.ledger_qy, 0)::NUMERIC, 4) as qy_ledger,
    ROUND(COALESCE(m.qn, 0)::NUMERIC, 4) as qn_markets,
    ROUND(COALESCE(ts.txn_qn, 0)::NUMERIC, 4) as txn_qn,
    ROUND(COALESCE(ls.ledger_qn, 0)::NUMERIC, 4) as qn_ledger,
    (ABS(COALESCE(m.qy, 0) - COALESCE(ts.txn_qy, 0)) > 0.01 OR 
     ABS(COALESCE(m.qy, 0) - COALESCE(ls.ledger_qy, 0)) > 0.01) as qy_mismatch,
    (ABS(COALESCE(m.qn, 0) - COALESCE(ts.txn_qn, 0)) > 0.01 OR 
     ABS(COALESCE(m.qn, 0) - COALESCE(ls.ledger_qn, 0)) > 0.01) as qn_mismatch
  FROM markets m
  LEFT JOIN txn_shares ts ON m.id = ts.market_id
  LEFT JOIN ledger_shares ls ON m.id = ls.market_id
  WHERE m.status = 'active'
  ORDER BY m.title;
END;
$function$
"
"public","run_positions_audit","CREATE OR REPLACE FUNCTION public.run_positions_audit()
 RETURNS TABLE(user_id uuid, market_id uuid, side_display text, positions_shares numeric, transactions_shares numeric, difference numeric, has_mismatch boolean)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  WITH transaction_shares AS (
    SELECT 
      t.user_id,
      t.market_id,
      (t.side = 'YES') as side_bool,
      ROUND(SUM(CASE WHEN t.type = 'buy' THEN t.shares ELSE 0 END)::NUMERIC, 4) -
      ROUND(SUM(CASE WHEN t.type = 'sell' THEN t.shares ELSE 0 END)::NUMERIC, 4) as calc_shares
    FROM transactions t
    WHERE t.type IN ('buy', 'sell')
    GROUP BY t.user_id, t.market_id, (t.side = 'YES')
  )
  SELECT 
    COALESCE(p.user_id, ts.user_id) as user_id,
    COALESCE(p.market_id, ts.market_id) as market_id,
    CASE WHEN COALESCE(p.side, ts.side_bool) THEN 'YES' ELSE 'NO' END as side_display,
    ROUND(COALESCE(p.shares, 0)::NUMERIC, 4) as positions_shares,
    ROUND(COALESCE(ts.calc_shares, 0)::NUMERIC, 4) as transactions_shares,
    ROUND(ABS(COALESCE(p.shares, 0) - COALESCE(ts.calc_shares, 0))::NUMERIC, 4) as difference,
    ABS(COALESCE(p.shares, 0) - COALESCE(ts.calc_shares, 0)) > 0.01 as has_mismatch
  FROM positions p
  FULL OUTER JOIN transaction_shares ts 
    ON p.user_id = ts.user_id 
    AND p.market_id = ts.market_id 
    AND p.side = ts.side_bool
  WHERE ABS(COALESCE(p.shares, 0) - COALESCE(ts.calc_shares, 0)) > 0.01
  ORDER BY ABS(COALESCE(p.shares, 0) - COALESCE(ts.calc_shares, 0)) DESC;
END;
$function$
"
"public","sell_shares_lmsr","CREATE OR REPLACE FUNCTION public.sell_shares_lmsr(p_market_id uuid, p_user_id uuid, p_outcome text, p_shares numeric)
 RETURNS TABLE(sale_price numeric, proceeds numeric, fee numeric, net_proceeds numeric, realized_pnl numeric)
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_b NUMERIC;
  v_yes_shares NUMERIC;
  v_no_shares NUMERIC;
  v_new_yes_shares NUMERIC;
  v_new_no_shares NUMERIC;
  v_old_cost NUMERIC;
  v_new_cost NUMERIC;
  v_proceeds NUMERIC;
  v_fee NUMERIC;
  v_net_proceeds NUMERIC;
  v_price NUMERIC;
  v_user_balance NUMERIC;
  v_position_shares NUMERIC;
  v_market_title TEXT;
  v_avg_cost_basis NUMERIC;
  v_realized_pnl NUMERIC;
BEGIN
  -- Get market parameters
  SELECT b, yes_shares, no_shares, title
  INTO v_b, v_yes_shares, v_no_shares, v_market_title
  FROM markets
  WHERE id = p_market_id AND status = 'open'
  FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Market not found or not open';
  END IF;

  -- Check user position
  SELECT shares INTO v_position_shares
  FROM market_participants
  WHERE market_id = p_market_id 
    AND user_id = p_user_id 
    AND outcome = p_outcome
  FOR UPDATE;

  IF v_position_shares IS NULL OR v_position_shares < p_shares THEN
    RAISE EXCEPTION 'Insufficient shares to sell';
  END IF;

  -- Get average cost basis for P&L calculation
  SELECT 
    COALESCE(SUM(CASE WHEN type = 'trade' THEN -amount ELSE 0 END) / 
    NULLIF(SUM(CASE WHEN type = 'trade' THEN shares ELSE 0 END), 0), 0)
  INTO v_avg_cost_basis
  FROM transactions
  WHERE user_id = p_user_id 
    AND market_id = p_market_id 
    AND outcome = p_outcome
    AND type = 'trade';

  -- Calculate old cost
  v_old_cost := v_b * LN(EXP(v_yes_shares / v_b) + EXP(v_no_shares / v_b));

  -- Calculate new shares after sale
  IF p_outcome = 'YES' THEN
    v_new_yes_shares := v_yes_shares - p_shares;
    v_new_no_shares := v_no_shares;
  ELSE
    v_new_yes_shares := v_yes_shares;
    v_new_no_shares := v_no_shares - p_shares;
  END IF;

  -- Calculate new cost
  v_new_cost := v_b * LN(EXP(v_new_yes_shares / v_b) + EXP(v_new_no_shares / v_b));

  -- Calculate proceeds and fee
  v_proceeds := ABS(v_old_cost - v_new_cost);
  v_fee := v_proceeds * 0.01;
  v_net_proceeds := v_proceeds - v_fee;
  v_price := v_proceeds / p_shares;

  -- Calculate realized P&L
  v_realized_pnl := v_net_proceeds - (v_avg_cost_basis * p_shares);

  -- Update market shares
  UPDATE markets
  SET yes_shares = v_new_yes_shares,
      no_shares = v_new_no_shares,
      updated_at = NOW()
  WHERE id = p_market_id;

  -- Removed invalid FOR UPDATE from UPDATE statement
  UPDATE users SET balance = balance + v_net_proceeds WHERE id = p_user_id;

  -- Update position
  UPDATE market_participants
  SET shares = shares - p_shares,
      updated_at = NOW()
  WHERE market_id = p_market_id 
    AND user_id = p_user_id 
    AND outcome = p_outcome;

  -- Record transaction with P&L
  INSERT INTO transactions (
    user_id, 
    market_id, 
    type, 
    amount, 
    balance_after, 
    description,
    outcome,
    shares,
    price,
    realized_pnl
  )
  VALUES (
    p_user_id,
    p_market_id,
    'sell',
    v_net_proceeds,
    (SELECT balance FROM users WHERE id = p_user_id),
    'Sold ' || ROUND(p_shares, 2) || ' ' || p_outcome || ' shares',
    p_outcome,
    p_shares,
    v_price,
    v_realized_pnl
  );

  -- Create notification with market_id
  INSERT INTO notifications (user_id, market_id, type, title, message, link)
  VALUES (
    p_user_id,
    p_market_id,
    'trade',
    'Shares Sold',
    'You sold ' || ROUND(p_shares, 2) || ' ' || p_outcome || ' shares for $' || ROUND(v_net_proceeds, 2) || ' in ""' || v_market_title || '""',
    '/market/' || p_market_id
  );

  RETURN QUERY SELECT v_price, v_proceeds, v_fee, v_net_proceeds, v_realized_pnl;
END;
$function$
"
"public","sell_shares_lmsr","CREATE OR REPLACE FUNCTION public.sell_shares_lmsr(p_position_id uuid, p_shares_to_sell numeric, p_expected_value numeric, p_market_id uuid, p_user_id uuid, p_qy numeric, p_qn numeric, p_yes_shares numeric, p_no_shares numeric, p_total_volume numeric, p_liquidity_pool numeric)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_position RECORD;
  v_market RECORD;
  v_sale_value NUMERIC;
  v_fee_amount NUMERIC;
  v_creator_fee NUMERIC;
  v_liquidity_fee NUMERIC;
  v_net_value NUMERIC;
  v_new_shares NUMERIC;
  v_cost_basis NUMERIC;
  v_realized_pnl NUMERIC;
  v_price_per_share NUMERIC;
  v_transaction_id UUID;
  v_balance_after NUMERIC;
BEGIN
  -- Lock and get position
  SELECT * INTO v_position
  FROM positions
  WHERE id = p_position_id
    AND user_id = p_user_id
  FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Position not found or does not belong to user';
  END IF;

  IF v_position.shares < p_shares_to_sell THEN
    RAISE EXCEPTION 'Insufficient shares to sell';
  END IF;

  -- Lock market
  SELECT * INTO v_market
  FROM markets
  WHERE id = p_market_id
  FOR UPDATE;

  IF v_market.status != 'active' THEN
    RAISE EXCEPTION 'Market is not active';
  END IF;

  -- Calculate sale value and fees
  v_sale_value := p_expected_value;
  v_fee_amount := v_sale_value * 0.01;
  v_creator_fee := v_fee_amount * 0.5;
  v_liquidity_fee := v_fee_amount * 0.5;
  v_net_value := v_sale_value - v_fee_amount;

  -- Calculate P&L metrics
  v_cost_basis := v_position.avg_price;
  v_price_per_share := v_sale_value / NULLIF(p_shares_to_sell, 0);
  v_realized_pnl := (v_price_per_share - v_cost_basis) * p_shares_to_sell;

  -- Update user balance (EXISTING FUNCTIONALITY)
  UPDATE profiles
  SET balance = balance + v_net_value
  WHERE id = p_user_id
  RETURNING balance INTO v_balance_after;

  -- Update market state (EXISTING FUNCTIONALITY)
  UPDATE markets
  SET 
    qy = p_qy,
    qn = p_qn,
    yes_shares = p_yes_shares,
    no_shares = p_no_shares,
    total_volume = p_total_volume,
    liquidity_pool = p_liquidity_pool
  WHERE id = p_market_id;

  -- Update or delete position (EXISTING FUNCTIONALITY)
  v_new_shares := v_position.shares - p_shares_to_sell;
  
  IF v_new_shares < 0.01 THEN
    DELETE FROM positions WHERE id = p_position_id;
  ELSE
    UPDATE positions
    SET 
      shares = v_new_shares,
      amount_invested = amount_invested - (v_position.avg_price * p_shares_to_sell)
    WHERE id = p_position_id;
  END IF;

  -- Store transaction (EXISTING FUNCTIONALITY)
  INSERT INTO transactions (
    user_id,
    market_id,
    type,
    amount,
    shares,
    price_per_share,
    cost_basis,
    realized_pnl,
    side,
    description
  )
  VALUES (
    p_user_id,
    p_market_id,
    'sell',
    v_net_value,
    p_shares_to_sell,
    v_price_per_share,
    v_cost_basis,
    v_realized_pnl,
    CASE WHEN v_position.side THEN 'YES' ELSE 'NO' END,
    'Sold ' || p_shares_to_sell || ' ' || CASE WHEN v_position.side THEN 'YES' ELSE 'NO' END || ' shares for $' || ROUND(v_net_value, 2)
  )
  RETURNING id INTO v_transaction_id;

  -- Removed manual ledger entry insertion - now handled by event-sourced trigger on transactions table

  -- Create notification using 'trade' type
  INSERT INTO notifications (user_id, market_id, type, title, message, link)
  VALUES (
    p_user_id,
    p_market_id,
    'trade',
    'Shares Sold',
    'Sold ' || p_shares_to_sell || ' shares for $' || ROUND(v_net_value, 2) || ' (P&L: $' || ROUND(v_realized_pnl, 2) || ')',
    '/market/' || p_market_id
  );

  RETURN json_build_object(
    'success', true,
    'net_value', v_net_value,
    'fee_amount', v_fee_amount,
    'realized_pnl', v_realized_pnl,
    'transaction_id', v_transaction_id
  );
END;
$function$
"
"public","sell_shares_lmsr_v2","CREATE OR REPLACE FUNCTION public.sell_shares_lmsr_v2(p_market_id uuid, p_user_id uuid, p_shares_to_sell numeric, p_expected_price numeric)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_market_record RECORD;
    v_position RECORD;
    v_current_qy NUMERIC;
    v_current_qn NUMERIC;
    v_b NUMERIC;
    v_current_price NUMERIC;
    v_slippage NUMERIC;
    v_side_boolean BOOLEAN;
    v_gross_value NUMERIC;
    v_total_fee NUMERIC;
    v_platform_fee NUMERIC;
    v_creator_fee NUMERIC;
    v_net_value NUMERIC;
    v_new_qy NUMERIC;
    v_new_qn NUMERIC;
    v_cost_basis NUMERIC;
    v_realized_pnl NUMERIC;
    v_transaction_id UUID;
    -- Account IDs
    v_user_account_id UUID;
    v_pool_account_id UUID;
    v_creator_fees_account_id UUID;
    v_platform_account_id UUID;
    -- Cents for ledger
    v_gross_value_cents BIGINT;
    v_net_value_cents BIGINT;
    v_platform_fee_cents BIGINT;
    v_creator_fee_cents BIGINT;
BEGIN
    -- 1. LOCK: Acquire advisory lock on market
    PERFORM pg_advisory_xact_lock(hashtext(p_market_id::text));
    
    -- 2. FETCH CURRENT STATE
    SELECT m.*, m.b as liquidity_parameter
    INTO v_market_record
    FROM markets m
    WHERE m.id = p_market_id
    FOR UPDATE;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Market not found: %', p_market_id;
    END IF;
    
    IF v_market_record.status != 'active' THEN
        RAISE EXCEPTION 'Market is not active. Current status: %', v_market_record.status;
    END IF;
    
    -- 3. FETCH USER POSITION
    SELECT * INTO v_position
    FROM positions
    WHERE user_id = p_user_id AND market_id = p_market_id AND shares > 0
    FOR UPDATE;
    
    IF NOT FOUND THEN
        RAISE EXCEPTION 'No position found for user in this market';
    END IF;
    
    IF v_position.shares < p_shares_to_sell THEN
        RAISE EXCEPTION 'Insufficient shares. Have: %, Want to sell: %', 
            ROUND(v_position.shares, 4), ROUND(p_shares_to_sell, 4);
    END IF;
    
    v_side_boolean := v_position.side;
    
    -- Get current values
    v_current_qy := COALESCE(v_market_record.qy, 0);
    v_current_qn := COALESCE(v_market_record.qn, 0);
    v_b := COALESCE(v_market_record.liquidity_parameter, 100);
    
    -- 4. CALCULATE CURRENT PRICE
    IF v_side_boolean THEN
        v_current_price := EXP(v_current_qy / v_b) / (EXP(v_current_qy / v_b) + EXP(v_current_qn / v_b));
    ELSE
        v_current_price := EXP(v_current_qn / v_b) / (EXP(v_current_qy / v_b) + EXP(v_current_qn / v_b));
    END IF;
    
    -- 5. VALIDATE SLIPPAGE (2% tolerance)
    v_slippage := ABS(v_current_price - p_expected_price) / NULLIF(p_expected_price, 0);
    IF v_slippage > 0.02 THEN
        RAISE EXCEPTION 'Price slippage too high: %. Current price: %, Expected: %', 
            ROUND(v_slippage * 100, 2) || '%', ROUND(v_current_price, 4), ROUND(p_expected_price, 4);
    END IF;
    
    -- 6. CALCULATE GROSS VALUE using LMSR
    IF v_side_boolean THEN
        v_new_qy := v_current_qy - p_shares_to_sell;
        v_new_qn := v_current_qn;
        v_gross_value := v_b * LN(
            (EXP(v_current_qy / v_b) + EXP(v_current_qn / v_b)) / 
            (EXP(v_new_qy / v_b) + EXP(v_new_qn / v_b))
        );
    ELSE
        v_new_qy := v_current_qy;
        v_new_qn := v_current_qn - p_shares_to_sell;
        v_gross_value := v_b * LN(
            (EXP(v_current_qy / v_b) + EXP(v_current_qn / v_b)) / 
            (EXP(v_new_qy / v_b) + EXP(v_new_qn / v_b))
        );
    END IF;
    
    v_gross_value := ROUND(v_gross_value, 4);
    
    -- 7. CALCULATE FEES (1% total from GROSS)
    v_total_fee := ROUND(v_gross_value * 0.01, 4);
    v_platform_fee := ROUND(v_total_fee * 0.5, 4);
    v_creator_fee := v_total_fee - v_platform_fee;
    v_net_value := v_gross_value - v_total_fee;  -- What user actually receives
    
    -- Convert to cents
    v_gross_value_cents := (v_gross_value * 100)::BIGINT;
    v_net_value_cents := (v_net_value * 100)::BIGINT;
    v_platform_fee_cents := (v_platform_fee * 100)::BIGINT;
    v_creator_fee_cents := (v_creator_fee * 100)::BIGINT;
    
    -- Calculate cost basis and P&L
    v_cost_basis := (v_position.amount_invested / v_position.shares) * p_shares_to_sell;
    v_realized_pnl := v_net_value - v_cost_basis;
    
    -- 8. CREDIT USER BALANCE (NET amount)
    UPDATE profiles
    SET balance = balance + v_net_value,
        updated_at = NOW()
    WHERE id = p_user_id;
    
    -- 9. GET OR CREATE ACCOUNTS
    v_user_account_id := get_or_create_account(p_user_id, 'user');
    v_pool_account_id := get_or_create_account(p_market_id, 'market_pool');
    v_creator_fees_account_id := get_or_create_account(p_market_id, 'market_creator_fees');
    v_platform_account_id := get_or_create_account(
        '00000000-0000-0000-0000-000000000000'::UUID,
        'platform'
    );
    
    -- 10. CREATE SHARES LEDGER ENTRIES
    -- Debit user shares
    PERFORM create_shares_ledger_entry(
        p_market_id,
        p_user_id,
        'user',
        v_side_boolean,
        p_shares_to_sell,
        0,
        'sell',
        'Sell ' || CASE WHEN v_side_boolean THEN 'YES' ELSE 'NO' END || ' shares',
        NULL
    );
    
    -- Credit market (market receives shares back)
    PERFORM create_shares_ledger_entry(
        p_market_id,
        NULL,
        'market',
        v_side_boolean,
        0,
        p_shares_to_sell,
        'sell',
        'Market receives ' || CASE WHEN v_side_boolean THEN 'YES' ELSE 'NO' END || ' shares back',
        NULL
    );
    
    -- 11. CREATE MONEY LEDGER ENTRIES
    -- Credit user for NET amount (what they receive)
    PERFORM create_ledger_entry(
        v_user_account_id,
        'credit',
        v_net_value_cents,
        'trade',
        NULL,
        p_user_id,
        p_market_id,
        'Sell trade proceeds (net after fees): $' || ROUND(v_net_value, 2),
        jsonb_build_object('trade_type', 'sell', 'side', CASE WHEN v_side_boolean THEN 'YES' ELSE 'NO' END)
    );
    
    -- Debit pool for GROSS amount
    PERFORM create_ledger_entry(
        v_pool_account_id,
        'debit',
        v_gross_value_cents,
        'trade',
        NULL,
        p_user_id,
        p_market_id,
        'Pool pays for sell trade (gross): $' || ROUND(v_gross_value, 2),
        jsonb_build_object('trade_type', 'sell', 'side', CASE WHEN v_side_boolean THEN 'YES' ELSE 'NO' END)
    );
    
    -- Credit platform fee
    PERFORM create_ledger_entry(
        v_platform_account_id,
        'credit',
        v_platform_fee_cents,
        'trade_fee',
        NULL,
        p_user_id,
        p_market_id,
        'Platform fee from sell trade: $' || ROUND(v_platform_fee, 2),
        jsonb_build_object('trade_type', 'sell', 'fee_type', 'platform')
    );
    
    -- Credit creator fees account
    PERFORM create_ledger_entry(
        v_creator_fees_account_id,
        'credit',
        v_creator_fee_cents,
        'trade_fee',
        NULL,
        p_user_id,
        p_market_id,
        'Creator fee from sell trade: $' || ROUND(v_creator_fee, 2),
        jsonb_build_object('trade_type', 'sell', 'fee_type', 'creator')
    );
    
    -- 12. INSERT INTO FEES TABLE
    -- Creator fee record
    INSERT INTO fees (
        user_id,
        market_id,
        transaction_type,
        original_amount,
        fee_amount,
        fee_percentage,
        net_amount,
        fee_type,
        paid_out,
        created_at
    ) VALUES (
        v_market_record.creator_id,
        p_market_id,
        'sell',
        v_gross_value,
        v_creator_fee,
        0.005,
        v_creator_fee,
        'creator',
        false,
        NOW()
    );
    
    -- Platform fee record
    INSERT INTO fees (
        user_id,
        market_id,
        transaction_type,
        original_amount,
        fee_amount,
        fee_percentage,
        net_amount,
        fee_type,
        paid_out,
        created_at
    ) VALUES (
        p_user_id,
        p_market_id,
        'sell',
        v_gross_value,
        v_platform_fee,
        0.005,
        v_platform_fee,
        'site',
        false,
        NOW()
    );
    
    -- 13. UPDATE MARKETS TABLE
    UPDATE markets
    SET qy = ROUND(v_new_qy, 4),
        qn = ROUND(v_new_qn, 4),
        yes_shares = COALESCE(yes_shares, 0) - CASE WHEN v_side_boolean THEN p_shares_to_sell ELSE 0 END,
        no_shares = COALESCE(no_shares, 0) - CASE WHEN NOT v_side_boolean THEN p_shares_to_sell ELSE 0 END,
        liquidity_pool = COALESCE(liquidity_pool, 0) - v_gross_value,
        total_volume = COALESCE(total_volume, 0) + v_gross_value,
        creator_fees_earned = COALESCE(creator_fees_earned, 0) + v_creator_fee,
        updated_at = NOW()
    WHERE id = p_market_id;
    
    -- 14. UPDATE POSITION
    IF v_position.shares = p_shares_to_sell THEN
        DELETE FROM positions WHERE id = v_position.id;
    ELSE
        UPDATE positions
        SET shares = shares - p_shares_to_sell,
            amount_invested = amount_invested - v_cost_basis,
            updated_at = NOW()
        WHERE id = v_position.id;
    END IF;
    
    -- 15. CREATE TRANSACTION RECORD
    INSERT INTO transactions (
        user_id, market_id, type, amount, shares, price_per_share, cost_basis, realized_pnl, side, description
    ) VALUES (
        p_user_id, p_market_id, 'sell', v_net_value, p_shares_to_sell, v_current_price,
        v_cost_basis, v_realized_pnl, CASE WHEN v_side_boolean THEN 'YES' ELSE 'NO' END,
        'Sold ' || ROUND(p_shares_to_sell, 2) || ' shares at $' || ROUND(v_current_price, 4)
    )
    RETURNING id INTO v_transaction_id;
    
    -- 16. CREATE NOTIFICATION
    INSERT INTO notifications (user_id, type, title, message, market_id, created_at)
    VALUES (
        p_user_id,
        'trade_executed',
        'Trade Executed',
        'Your sell order for ' || ROUND(p_shares_to_sell, 2) || ' ' || 
        CASE WHEN v_side_boolean THEN 'YES' ELSE 'NO' END || 
        ' shares has been executed. You received $' || ROUND(v_net_value, 2) || '.',
        p_market_id,
        NOW()
    );
    
    RETURN jsonb_build_object(
        'success', true,
        'transaction_id', v_transaction_id,
        'shares_sold', ROUND(p_shares_to_sell, 4),
        'price', ROUND(v_current_price, 4),
        'gross_value', ROUND(v_gross_value, 4),
        'net_value', ROUND(v_net_value, 4),
        'platform_fee', ROUND(v_platform_fee, 4),
        'creator_fee', ROUND(v_creator_fee, 4),
        'realized_pnl', ROUND(v_realized_pnl, 4),
        'new_qy', ROUND(v_new_qy, 4),
        'new_qn', ROUND(v_new_qn, 4)
    );
END;
$function$
"
"public","sell_shares_lmsr_v2","CREATE OR REPLACE FUNCTION public.sell_shares_lmsr_v2(p_market_id uuid, p_user_id uuid, p_shares_to_sell numeric, p_bet_side character varying, p_expected_price numeric DEFAULT NULL::numeric)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_market RECORD;
    v_position RECORD;
    v_current_qy NUMERIC;
    v_current_qn NUMERIC;
    v_b NUMERIC;
    v_spot_price NUMERIC;
    v_execution_price NUMERIC;
    v_slippage NUMERIC;
    v_slippage_tolerance NUMERIC;
    v_side_boolean BOOLEAN;
    v_gross_value NUMERIC;
    v_total_fee NUMERIC;
    v_platform_fee NUMERIC;
    v_creator_fee NUMERIC;
    v_net_value NUMERIC;
    v_new_qy NUMERIC;
    v_new_qn NUMERIC;
    v_cost_basis NUMERIC;
    v_realized_pnl NUMERIC;
    v_user_account_id UUID;
    v_pool_account_id UUID;
    v_platform_account_id UUID;
    v_creator_fee_account_id UUID;
    v_gross_value_cents BIGINT;
    v_net_value_cents BIGINT;
    v_platform_fee_cents BIGINT;
    v_creator_fee_cents BIGINT;
    v_transaction_id UUID;
    v_transaction_group_id UUID := gen_random_uuid();
BEGIN
    -- 1. ACQUIRE ADVISORY LOCK on market
    PERFORM pg_advisory_xact_lock(hashtext(p_market_id::text));
    
    -- 2. PARSE SIDE
    v_side_boolean := LOWER(p_bet_side) IN ('yes', 'y', 'true', '1');
    
    -- 3. GET USER POSITION
    SELECT shares, avg_price, amount_invested
    INTO v_position
    FROM positions
    WHERE user_id = p_user_id
      AND market_id = p_market_id
      AND side = v_side_boolean
    FOR UPDATE;
    
    IF v_position IS NULL OR v_position.shares < p_shares_to_sell THEN
        RAISE EXCEPTION 'Insufficient shares. Have: %, Want to sell: %', 
            COALESCE(ROUND(v_position.shares, 4), 0), ROUND(p_shares_to_sell, 4);
    END IF;
    
    -- 4. GET CURRENT MARKET STATE
    SELECT id, qy, qn, b, status, creator_id
    INTO v_market
    FROM markets
    WHERE id = p_market_id
    FOR UPDATE;
    
    IF v_market IS NULL THEN
        RAISE EXCEPTION 'Market not found: %', p_market_id;
    END IF;
    
    IF v_market.status != 'active' THEN
        RAISE EXCEPTION 'Market is not open for trading. Status: %', v_market.status;
    END IF;
    
    v_current_qy := COALESCE(v_market.qy, 0);
    v_current_qn := COALESCE(v_market.qn, 0);
    v_b := COALESCE(v_market.b, 100 / LN(2) - 1);
    
    -- 5. CALCULATE SPOT PRICE (for reference)
    IF v_side_boolean THEN
        v_spot_price := EXP(v_current_qy / v_b) / (EXP(v_current_qy / v_b) + EXP(v_current_qn / v_b));
    ELSE
        v_spot_price := EXP(v_current_qn / v_b) / (EXP(v_current_qy / v_b) + EXP(v_current_qn / v_b));
    END IF;
    
    -- 6. GET USER'S SLIPPAGE TOLERANCE (default 5%)
    SELECT COALESCE(slippage_tolerance, 5.00) / 100.0 
    INTO v_slippage_tolerance
    FROM profiles 
    WHERE id = p_user_id;
    
    v_slippage_tolerance := COALESCE(v_slippage_tolerance, 0.05);
    
    -- 7. CALCULATE GROSS VALUE using LMSR
    IF v_side_boolean THEN
        v_new_qy := v_current_qy - p_shares_to_sell;
        v_new_qn := v_current_qn;
        v_gross_value := v_b * LN(
            (EXP(v_current_qy / v_b) + EXP(v_current_qn / v_b)) / 
            (EXP(v_new_qy / v_b) + EXP(v_new_qn / v_b))
        );
    ELSE
        v_new_qy := v_current_qy;
        v_new_qn := v_current_qn - p_shares_to_sell;
        v_gross_value := v_b * LN(
            (EXP(v_current_qy / v_b) + EXP(v_current_qn / v_b)) / 
            (EXP(v_new_qy / v_b) + EXP(v_new_qn / v_b))
        );
    END IF;
    
    v_gross_value := ROUND(v_gross_value, 4);
    
    -- 8. CALCULATE EXECUTION PRICE
    v_execution_price := ROUND(v_gross_value / p_shares_to_sell, 4);
    
    -- 9. VALIDATE SLIPPAGE (using user's tolerance against EXECUTION price)
    IF p_expected_price IS NOT NULL THEN
        v_slippage := ABS(v_execution_price - p_expected_price) / NULLIF(p_expected_price, 0);
        IF v_slippage > v_slippage_tolerance THEN
            RAISE EXCEPTION 'Price slippage too high: %. Execution price: %, Expected: %, Your tolerance: %', 
                ROUND(v_slippage * 100, 2) || '%', ROUND(v_execution_price, 4), ROUND(p_expected_price, 4),
                ROUND(v_slippage_tolerance * 100, 1) || '%';
        END IF;
    END IF;
    
    -- 10. CALCULATE FEES (1% total from GROSS)
    v_total_fee := ROUND(v_gross_value * 0.01, 4);
    v_platform_fee := ROUND(v_total_fee * 0.5, 4);
    v_creator_fee := v_total_fee - v_platform_fee;
    v_net_value := v_gross_value - v_total_fee;
    
    v_gross_value_cents := (v_gross_value * 100)::BIGINT;
    v_net_value_cents := (v_net_value * 100)::BIGINT;
    v_platform_fee_cents := (v_platform_fee * 100)::BIGINT;
    v_creator_fee_cents := (v_creator_fee * 100)::BIGINT;
    
    -- 11. Calculate cost basis and P&L
    v_cost_basis := (v_position.amount_invested / v_position.shares) * p_shares_to_sell;
    v_realized_pnl := v_net_value - v_cost_basis;
    
    -- 12. CREDIT USER BALANCE
    UPDATE profiles
    SET balance = balance + v_net_value
    WHERE id = p_user_id;
    
    -- 13. GET OR CREATE LEDGER ACCOUNTS
    SELECT get_or_create_account(p_user_id, 'user') INTO v_user_account_id;
    SELECT get_or_create_account(p_market_id, 'market_pool') INTO v_pool_account_id;
    SELECT get_or_create_account('00000000-0000-0000-0000-000000000001'::uuid, 'platform') INTO v_platform_account_id;
    SELECT get_or_create_account(p_market_id, 'market_creator_fees') INTO v_creator_fee_account_id;
    
    -- 14. CREATE LEDGER ENTRIES
    PERFORM create_ledger_entry(
        v_pool_account_id, p_user_id, 'debit', v_gross_value_cents, 'trade',
        NULL, p_market_id, 'market_pool', v_transaction_group_id,
        'Market pool debit for sell'
    );
    
    PERFORM create_ledger_entry(
        v_user_account_id, p_user_id, 'credit', v_net_value_cents, 'trade',
        NULL, p_market_id, 'user', v_transaction_group_id,
        'Sell ' || CASE WHEN v_side_boolean THEN 'YES' ELSE 'NO' END || ' shares'
    );
    
    PERFORM create_ledger_entry(
        v_platform_account_id, p_user_id, 'credit', v_platform_fee_cents, 'platform_fee',
        NULL, p_market_id, 'platform', v_transaction_group_id,
        'Platform fee'
    );
    
    PERFORM create_ledger_entry(
        v_creator_fee_account_id, p_user_id, 'credit', v_creator_fee_cents, 'creator_fee',
        NULL, p_market_id, 'market_creator_fees', v_transaction_group_id,
        'Creator fee'
    );
    
    -- 15. CREATE SHARES LEDGER ENTRIES
    PERFORM create_shares_ledger_entry(
        p_market_id, p_user_id, 'user', v_side_boolean,
        p_shares_to_sell, 0::NUMERIC, 'sell',
        'Sell ' || CASE WHEN v_side_boolean THEN 'YES' ELSE 'NO' END || ' shares',
        '{}'::JSONB
    );
    
    PERFORM create_shares_ledger_entry(
        p_market_id, NULL::UUID, 'market', v_side_boolean,
        0::NUMERIC, p_shares_to_sell, 'sell',
        'Market redeemed shares',
        '{}'::JSONB
    );
    
    -- 16. INSERT INTO FEES TABLE
    INSERT INTO fees (
        user_id, market_id, transaction_type, original_amount, fee_amount, 
        fee_percentage, net_amount, fee_type, paid_out, created_at
    ) VALUES (
        v_market.creator_id, p_market_id, 'sell', v_gross_value, v_creator_fee,
        0.005, v_creator_fee, 'creator', false, NOW()
    );
    
    INSERT INTO fees (
        user_id, market_id, transaction_type, original_amount, fee_amount,
        fee_percentage, net_amount, fee_type, paid_out, created_at
    ) VALUES (
        p_user_id, p_market_id, 'sell', v_gross_value, v_platform_fee,
        0.005, v_platform_fee, 'site', false, NOW()
    );
    
    -- 17. UPDATE MARKETS TABLE
    UPDATE markets
    SET qy = ROUND(v_new_qy, 4),
        qn = ROUND(v_new_qn, 4),
        yes_shares = GREATEST(0, COALESCE(yes_shares, 0) - CASE WHEN v_side_boolean THEN p_shares_to_sell ELSE 0 END),
        no_shares = GREATEST(0, COALESCE(no_shares, 0) - CASE WHEN NOT v_side_boolean THEN p_shares_to_sell ELSE 0 END),
        total_volume = COALESCE(total_volume, 0) + v_gross_value,
        creator_fees_earned = COALESCE(creator_fees_earned, 0) + v_creator_fee,
        updated_at = NOW()
    WHERE id = p_market_id;
    
    -- 18. UPDATE POSITION
    IF v_position.shares = p_shares_to_sell THEN
        DELETE FROM positions
        WHERE user_id = p_user_id AND market_id = p_market_id AND side = v_side_boolean;
    ELSE
        UPDATE positions
        SET shares = shares - p_shares_to_sell,
            amount_invested = amount_invested - v_cost_basis
        WHERE user_id = p_user_id AND market_id = p_market_id AND side = v_side_boolean;
    END IF;
    
    -- 19. CREATE TRANSACTION RECORD (using correct columns from working version)
    INSERT INTO transactions (
        user_id, market_id, type, amount, shares, price_per_share, cost_basis, realized_pnl, side, description
    ) VALUES (
        p_user_id, p_market_id, 'sell', v_net_value, p_shares_to_sell, v_execution_price,
        v_cost_basis, v_realized_pnl, CASE WHEN v_side_boolean THEN 'YES' ELSE 'NO' END,
        'Sold ' || ROUND(p_shares_to_sell, 2) || ' shares at $' || ROUND(v_execution_price, 4) || ' per share'
    )
    RETURNING id INTO v_transaction_id;
    
    -- 20. CREATE NOTIFICATION
    INSERT INTO notifications (user_id, type, title, message, market_id, created_at)
    VALUES (
        p_user_id,
        'trade_executed',
        'Trade Executed',
        'Sold ' || ROUND(p_shares_to_sell, 2) || ' ' || 
        CASE WHEN v_side_boolean THEN 'YES' ELSE 'NO' END || 
        ' shares at $' || ROUND(v_execution_price, 4) || ' per share. You received $' || ROUND(v_net_value, 2),
        p_market_id,
        NOW()
    );
    
    RETURN jsonb_build_object(
        'success', true,
        'transaction_id', v_transaction_id,
        'shares_sold', ROUND(p_shares_to_sell, 4),
        'execution_price', ROUND(v_execution_price, 4),
        'spot_price', ROUND(v_spot_price, 4),
        'gross_value', ROUND(v_gross_value, 4),
        'net_value', ROUND(v_net_value, 4),
        'fees', ROUND(v_total_fee, 4),
        'realized_pnl', ROUND(v_realized_pnl, 4)
    );
END;
$function$
"
"public","sell_shares_v3","CREATE OR REPLACE FUNCTION public.sell_shares_v3(p_user_id uuid, p_market_id uuid, p_side text, p_shares numeric, p_min_payout numeric DEFAULT 0)
 RETURNS TABLE(success boolean, payout numeric, price_per_share numeric, new_yes_price numeric, new_no_price numeric, fee_amount numeric, message text)
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_market RECORD;
    v_position RECORD;
    v_current_price NUMERIC;
    v_base_payout NUMERIC;
    v_fee NUMERIC;
    v_net_payout NUMERIC;
    v_new_k NUMERIC;
    v_new_yes NUMERIC;
    v_new_no NUMERIC;
    v_new_yes_price NUMERIC;
    v_new_no_price NUMERIC;
    v_creator_fee NUMERIC;
    v_platform_fee NUMERIC;
    v_slippage_tolerance NUMERIC;
    v_min_acceptable_payout NUMERIC;
BEGIN
    -- Get market info
    SELECT m.*, p.slippage_tolerance 
    INTO v_market
    FROM markets m
    LEFT JOIN profiles p ON p.id = p_user_id
    WHERE m.id = p_market_id;
    
    IF NOT FOUND THEN
        RETURN QUERY SELECT false, 0::NUMERIC, 0::NUMERIC, 0::NUMERIC, 0::NUMERIC, 0::NUMERIC, 'Market not found'::TEXT;
        RETURN;
    END IF;
    
    IF v_market.status != 'open' THEN
        RETURN QUERY SELECT false, 0::NUMERIC, 0::NUMERIC, 0::NUMERIC, 0::NUMERIC, 0::NUMERIC, 'Market is not open for trading'::TEXT;
        RETURN;
    END IF;
    
    -- Get user position
    SELECT * INTO v_position
    FROM positions
    WHERE user_id = p_user_id AND market_id = p_market_id;
    
    IF NOT FOUND OR 
       (UPPER(p_side) = 'YES' AND COALESCE(v_position.yes_shares, 0) < p_shares) OR
       (UPPER(p_side) = 'NO' AND COALESCE(v_position.no_shares, 0) < p_shares) THEN
        RETURN QUERY SELECT false, 0::NUMERIC, 0::NUMERIC, 0::NUMERIC, 0::NUMERIC, 0::NUMERIC, 'Insufficient shares'::TEXT;
        RETURN;
    END IF;
    
    -- Calculate current price based on LMSR
    IF UPPER(p_side) = 'YES' THEN
        v_current_price := v_market.yes_pool / (v_market.yes_pool + v_market.no_pool);
    ELSE
        v_current_price := v_market.no_pool / (v_market.yes_pool + v_market.no_pool);
    END IF;
    
    -- Calculate payout using LMSR
    IF UPPER(p_side) = 'YES' THEN
        v_new_yes := v_market.yes_pool + p_shares;
        v_new_k := v_market.liquidity_parameter * LN(EXP(v_new_yes / v_market.liquidity_parameter) + EXP(v_market.no_pool / v_market.liquidity_parameter));
        v_base_payout := v_new_k - v_market.k_constant;
        v_new_no := v_market.no_pool;
    ELSE
        v_new_no := v_market.no_pool + p_shares;
        v_new_k := v_market.liquidity_parameter * LN(EXP(v_market.yes_pool / v_market.liquidity_parameter) + EXP(v_new_no / v_market.liquidity_parameter));
        v_base_payout := v_new_k - v_market.k_constant;
        v_new_yes := v_market.yes_pool;
    END IF;
    
    -- Calculate fees (same as buy: 2% total, split 50/50)
    v_fee := v_base_payout * 0.02;
    v_creator_fee := v_fee * 0.5;
    v_platform_fee := v_fee * 0.5;
    v_net_payout := v_base_payout - v_fee;
    
    -- Check slippage tolerance
    v_slippage_tolerance := COALESCE(v_market.slippage_tolerance, 0.05);
    v_min_acceptable_payout := p_shares * v_current_price * (1 - v_slippage_tolerance);
    
    IF p_min_payout > 0 AND v_net_payout < p_min_payout THEN
        RETURN QUERY SELECT false, v_net_payout, v_current_price, 0::NUMERIC, 0::NUMERIC, v_fee, 'Payout below minimum acceptable'::TEXT;
        RETURN;
    END IF;
    
    -- Update market pools
    UPDATE markets
    SET yes_pool = v_new_yes,
        no_pool = v_new_no,
        k_constant = v_new_k,
        total_volume = total_volume + v_base_payout,
        -- Removed: creator_fees_earned update (now handled by ledger trigger)
        updated_at = NOW()
    WHERE id = p_market_id;
    
    -- Update position
    IF UPPER(p_side) = 'YES' THEN
        UPDATE positions
        SET yes_shares = yes_shares - p_shares,
            updated_at = NOW()
        WHERE user_id = p_user_id AND market_id = p_market_id;
    ELSE
        UPDATE positions
        SET no_shares = no_shares - p_shares,
            updated_at = NOW()
        WHERE user_id = p_user_id AND market_id = p_market_id;
    END IF;
    
    -- Update user balance
    UPDATE profiles
    SET balance = balance + v_net_payout
    WHERE id = p_user_id;
    
    -- Record transaction (this triggers ledger entries including creator_fees)
    INSERT INTO transactions (user_id, market_id, type, amount, shares, price_per_share, side)
    VALUES (p_user_id, p_market_id, 'sell', v_net_payout, p_shares, v_net_payout / p_shares, p_side);
    
    -- Calculate new prices
    v_new_yes_price := EXP(v_new_yes / v_market.liquidity_parameter) / 
                       (EXP(v_new_yes / v_market.liquidity_parameter) + EXP(v_new_no / v_market.liquidity_parameter));
    v_new_no_price := 1 - v_new_yes_price;
    
    RETURN QUERY SELECT true, v_net_payout, v_net_payout / p_shares, v_new_yes_price, v_new_no_price, v_fee, 'Sell successful'::TEXT;
END;
$function$
"
"public","settle_market","CREATE OR REPLACE FUNCTION public.settle_market(market_id_param uuid, outcome_param boolean, settler_id_param uuid)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_market RECORD;
  v_position RECORD;
  v_payout NUMERIC;
  v_total_payouts NUMERIC := 0;
  v_remaining_pool NUMERIC;
  v_liquidity_to_return NUMERIC;
  v_liquidity_sweep NUMERIC;
  v_initial_liquidity NUMERIC;
  v_creator_fees NUMERIC;
  v_winning_side TEXT;
  v_transaction_id UUID;
  v_is_public BOOLEAN;
  v_platform_account_id UUID;
BEGIN
  -- Get market details
  SELECT * INTO v_market FROM markets WHERE id = market_id_param;
  
  IF NOT FOUND THEN
    RETURN jsonb_build_object('success', false, 'error', 'Market not found');
  END IF;
  
  IF v_market.status = 'settled' THEN
    RETURN jsonb_build_object('success', false, 'error', 'Market already settled');
  END IF;

  -- Determine if public market
  v_is_public := NOT COALESCE(v_market.is_private, false);

  -- Calculate initial liquidity posted: (b + 1) * ln(2)
  -- For public markets, add $10 back (UMA reward was deducted on creation)
  v_initial_liquidity := (COALESCE(v_market.b, 0) + 1) * LN(2);
  IF v_is_public THEN
    v_initial_liquidity := v_initial_liquidity + 10;
  END IF;

  -- Determine winning side
  v_winning_side := CASE WHEN outcome_param THEN 'yes' ELSE 'no' END;
  
  -- Get initial pool for tracking
  v_remaining_pool := COALESCE(v_market.liquidity_pool, 0);
  
  -- Get creator fees to pay out (from markets table column)
  v_creator_fees := COALESCE(v_market.creator_fees_earned, 0);

  RAISE NOTICE 'Settling market % with outcome %, pool: %, creator_fees: %, initial_liquidity: %, is_public: %', 
    market_id_param, outcome_param, v_remaining_pool, v_creator_fees, v_initial_liquidity, v_is_public;

  -- Process winning positions - pay out $1 per share
  FOR v_position IN 
    SELECT p.*, pr.id as profile_id
    FROM positions p
    JOIN profiles pr ON pr.id = p.user_id
    WHERE p.market_id = market_id_param
      AND p.side = outcome_param  -- BOOLEAN comparison
      AND p.shares > 0.001
  LOOP
    -- Payout = shares * $1
    v_payout := ROUND(v_position.shares, 4);
    
    RAISE NOTICE 'Paying user % for % shares = $%', v_position.user_id, v_position.shares, v_payout;
    
    -- Create settlement payout transaction
    INSERT INTO transactions (
      id, user_id, market_id, type, amount, shares, side, description, created_at
    ) VALUES (
      gen_random_uuid(),
      v_position.user_id,
      market_id_param,
      'settlement_payout',
      v_payout,
      v_position.shares,
      CASE WHEN outcome_param THEN 'yes' ELSE 'no' END,
      'Settlement payout for ' || ROUND(v_position.shares, 2) || ' winning shares',
      NOW()
    ) RETURNING id INTO v_transaction_id;
    
    -- Credit user balance
    UPDATE profiles 
    SET balance = balance + v_payout 
    WHERE id = v_position.user_id;
    
    -- Create notification for winner
    INSERT INTO notifications (user_id, market_id, type, title, message, is_read, created_at)
    VALUES (
      v_position.user_id,
      market_id_param,
      'settlement',
      'You Won!',
      'You received $' || ROUND(v_payout, 2)::TEXT || ' from market settlement.',
      false,
      NOW()
    );
    
    -- Track total payouts
    v_total_payouts := v_total_payouts + v_payout;
    v_remaining_pool := v_remaining_pool - v_payout;
    
    -- Zero out the position shares (they've been paid out, not sold)
    UPDATE positions 
    SET shares = 0, 
        updated_at = NOW()
    WHERE id = v_position.id;
  END LOOP;
  
  -- Update market liquidity pool after payouts
  UPDATE markets 
  SET liquidity_pool = v_remaining_pool 
  WHERE id = market_id_param;

  RAISE NOTICE 'After payouts, remaining pool: %, initial_liquidity cap: %', v_remaining_pool, v_initial_liquidity;

  -- Pay creator fees if any
  -- Creator fees are NOT deducted from liquidity pool
  -- They come from a separate ledger account (market_creator_fees)
  IF v_creator_fees > 0 THEN
    INSERT INTO transactions (
      id, user_id, market_id, type, amount, description, lp_debit, market_liquidity_pool, created_at
    ) VALUES (
      gen_random_uuid(),
      v_market.creator_id,
      market_id_param,
      'creator_payout',
      v_creator_fees,
      'Creator fees payout for market settlement',
      0,  -- No LP debit - comes from separate creator fees account
      v_remaining_pool,  -- Pool unchanged
      NOW()
    );
    
    UPDATE profiles 
    SET balance = balance + v_creator_fees 
    WHERE id = v_market.creator_id;
    
    -- Create notification for creator fees
    INSERT INTO notifications (user_id, market_id, type, title, message, is_read, created_at)
    VALUES (
      v_market.creator_id,
      market_id_param,
      'creator_fee',
      'Creator Fees Received',
      'You received $' || ROUND(v_creator_fees, 2)::TEXT || ' in creator fees.',
      false,
      NOW()
    );
  END IF;

  -- Cap liquidity return at initial liquidity posted
  -- Calculate how much to return to creator (capped at initial liquidity)
  v_liquidity_to_return := LEAST(v_remaining_pool, v_initial_liquidity);
  
  -- Calculate liquidity sweep (excess goes to platform)
  v_liquidity_sweep := v_remaining_pool - v_liquidity_to_return;

  RAISE NOTICE 'Liquidity return: %, Liquidity sweep: %', v_liquidity_to_return, v_liquidity_sweep;
  
  -- Return capped liquidity to creator
  IF v_liquidity_to_return > 0.01 THEN
    INSERT INTO transactions (
      id, user_id, market_id, type, amount, description, created_at
    ) VALUES (
      gen_random_uuid(),
      v_market.creator_id,
      market_id_param,
      'liquidity_return',
      v_liquidity_to_return,
      'Liquidity returned from market settlement (capped at initial: $' || ROUND(v_initial_liquidity, 2)::TEXT || ')',
      NOW()
    );
    
    UPDATE profiles 
    SET balance = balance + v_liquidity_to_return 
    WHERE id = v_market.creator_id;
    
    -- Create notification for liquidity return
    INSERT INTO notifications (user_id, market_id, type, title, message, is_read, created_at)
    VALUES (
      v_market.creator_id,
      market_id_param,
      'liquidity_returned',
      'Liquidity Returned',
      'You received $' || ROUND(v_liquidity_to_return, 2)::TEXT || ' in returned liquidity.',
      false,
      NOW()
    );
    
    v_remaining_pool := v_remaining_pool - v_liquidity_to_return;
  END IF;

  -- Liquidity sweep - excess pool funds go to platform
  IF v_liquidity_sweep > 0.01 THEN
    -- Get or create platform ledger account
    SELECT id INTO v_platform_account_id
    FROM ledger_accounts
    WHERE account_type = 'platform'
    LIMIT 1;
    
    -- Create liquidity sweep transaction
    INSERT INTO transactions (
      id, user_id, market_id, type, amount, description, created_at
    ) VALUES (
      gen_random_uuid(),
      settler_id_param,  -- Use settler as the user for the transaction
      market_id_param,
      'liquidity_sweep',
      v_liquidity_sweep,
      'Excess liquidity swept to platform ($' || ROUND(v_liquidity_sweep, 2)::TEXT || ' above initial liquidity cap)',
      NOW()
    );
    
    v_remaining_pool := v_remaining_pool - v_liquidity_sweep;
    
    RAISE NOTICE 'Liquidity sweep of $% to platform', v_liquidity_sweep;
  END IF;

  -- Update market to final state
  UPDATE markets SET
    status = 'settled',
    settlement_status = 'resolved',
    outcome = outcome_param,
    settled_at = NOW(),
    settled_by = settler_id_param,
    liquidity_pool = v_remaining_pool
  WHERE id = market_id_param;

  RAISE NOTICE 'Final pool after settlement: %', v_remaining_pool;

  RETURN jsonb_build_object(
    'success', true,
    'total_payouts', v_total_payouts,
    'creator_fees', v_creator_fees,
    'liquidity_returned', v_liquidity_to_return,
    'liquidity_sweep', v_liquidity_sweep,
    'initial_liquidity_cap', v_initial_liquidity,
    'final_pool', v_remaining_pool
  );
END;
$function$
"
"public","split_trading_fees_secure","CREATE OR REPLACE FUNCTION public.split_trading_fees_secure(p_market_id uuid, p_trader_id uuid, p_creator_id uuid, p_total_fee numeric)
 RETURNS void
 LANGUAGE plpgsql
 SET search_path TO 'public'
AS $function$
DECLARE
    creator_fee numeric;
    site_fee numeric;
BEGIN
    -- Calculate split fees (50/50 of the 1% total fee)
    creator_fee := p_total_fee / 2;  -- 0.5% to creator
    site_fee := p_total_fee / 2;      -- 0.5% to site
    
    -- Insert creator fee record
    INSERT INTO fees (
        market_id,
        user_id,
        fee_amount,
        original_amount,
        net_amount,
        fee_percentage,
        fee_type,
        transaction_type,
        created_at
    ) VALUES (
        p_market_id,
        p_creator_id,
        creator_fee,
        p_total_fee,
        creator_fee,
        0.005,  -- 0.5% for creator
        'creator_fee',
        'buy',
        NOW()
    );
    
    -- Insert site fee record
    INSERT INTO fees (
        market_id,
        user_id,
        fee_amount,
        original_amount,
        net_amount,
        fee_percentage,
        fee_type,
        transaction_type,
        created_at
    ) VALUES (
        p_market_id,
        p_trader_id,
        site_fee,
        p_total_fee,
        site_fee,
        0.005,  -- 0.5% for site
        'site_fee',
        'buy',
        NOW()
    );
    
    -- Update market creator's total fees earned
    UPDATE markets 
    SET creator_fees_earned = COALESCE(creator_fees_earned, 0) + creator_fee
    WHERE id = p_market_id;
    
END;
$function$
"
"public","submit_vote","CREATE OR REPLACE FUNCTION public.submit_vote(p_contest_id uuid, p_voter_id uuid, p_vote_outcome boolean)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_vote_deadline TIMESTAMP;
  v_voter_balance NUMERIC;
  v_vote_bond_amount NUMERIC := 25;
  v_market_id UUID;
  v_market_title TEXT;
  v_creator_id UUID;
  v_contestant_id UUID;
  v_total_votes INT;
  v_votes_for_creator INT;
  v_votes_for_contestant INT;
BEGIN
  -- Check for 'voting' status
  SELECT sc.vote_deadline, sc.market_id, sc.contestant_id, m.title, m.creator_id
  INTO v_vote_deadline, v_market_id, v_contestant_id, v_market_title, v_creator_id
  FROM settlement_contests sc
  JOIN markets m ON m.id = sc.market_id
  WHERE sc.id = p_contest_id AND sc.status = 'voting';

  IF v_vote_deadline IS NULL THEN
    RAISE EXCEPTION 'Contest not found or voting has ended';
  END IF;

  IF NOW() > v_vote_deadline THEN
    RAISE EXCEPTION 'Voting period has expired';
  END IF;

  -- Verify voter was notified
  IF NOT EXISTS (
    SELECT 1 FROM notifications
    WHERE market_id = v_market_id 
    AND user_id = p_voter_id 
    AND type = 'vote_requested'
  ) THEN
    RAISE EXCEPTION 'You were not selected to vote on this settlement';
  END IF;

  -- Check if already voted
  IF EXISTS (
    SELECT 1 FROM settlement_votes
    WHERE contest_id = p_contest_id AND voter_id = p_voter_id
  ) THEN
    RAISE EXCEPTION 'You have already voted on this settlement';
  END IF;

  -- Check voter has sufficient balance
  SELECT balance INTO v_voter_balance
  FROM profiles
  WHERE id = p_voter_id;

  IF v_voter_balance < v_vote_bond_amount THEN
    RAISE EXCEPTION 'Insufficient balance to post vote bond';
  END IF;

  -- Deduct vote bond from voter
  UPDATE profiles
  SET balance = balance - v_vote_bond_amount
  WHERE id = p_voter_id;

  -- Record the vote
  INSERT INTO settlement_votes (
    contest_id,
    voter_id,
    vote_outcome,
    vote_bond_amount,
    created_at
  ) VALUES (
    p_contest_id,
    p_voter_id,
    p_vote_outcome,
    v_vote_bond_amount,
    NOW()
  );

  -- Count current votes
  SELECT 
    COUNT(*),
    COUNT(*) FILTER (WHERE vote_outcome = (SELECT outcome_chosen FROM settlement_bonds WHERE market_id = v_market_id)),
    COUNT(*) FILTER (WHERE vote_outcome != (SELECT outcome_chosen FROM settlement_bonds WHERE market_id = v_market_id))
  INTO v_total_votes, v_votes_for_creator, v_votes_for_contestant
  FROM settlement_votes
  WHERE contest_id = p_contest_id;

  -- Notify creator about vote progress
  INSERT INTO notifications (
    user_id,
    type,
    title,
    message,
    market_id,
    created_at,
    is_read
  ) VALUES (
    v_creator_id,
    'vote_cast',
    'Vote Cast on Your Settlement',
    'A vote has been cast on ""' || v_market_title || '"". Current tally: ' || 
    v_votes_for_creator || ' supporting your outcome, ' || v_votes_for_contestant || ' supporting the contest.',
    v_market_id,
    NOW(),
    false
  );

  -- Notify contestant about vote progress
  INSERT INTO notifications (
    user_id,
    type,
    title,
    message,
    market_id,
    created_at,
    is_read
  ) VALUES (
    v_contestant_id,
    'vote_cast',
    'Vote Cast on Settlement Contest',
    'A vote has been cast on ""' || v_market_title || '"". Current tally: ' || 
    v_votes_for_creator || ' for creator outcome, ' || v_votes_for_contestant || ' for your contested outcome.',
    v_market_id,
    NOW(),
    false
  );

  RETURN json_build_object(
    'success', true,
    'vote_recorded', true,
    'bond_amount', v_vote_bond_amount,
    'total_votes', v_total_votes
  );
END;
$function$
"
"public","submit_vote_v2","CREATE OR REPLACE FUNCTION public.submit_vote_v2(p_contest_id uuid, p_voter_id uuid, p_vote_outcome text)
 RETURNS jsonb
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    v_contest RECORD;
    v_market RECORD;
    v_vote_id UUID;
    v_vote_outcome_bool BOOLEAN;
    v_vote_bond_amount NUMERIC := 25.00;
    v_voter_balance NUMERIC;
BEGIN
    -- Convert text outcome to boolean
    IF LOWER(p_vote_outcome) = 'yes' THEN
        v_vote_outcome_bool := TRUE;
    ELSIF LOWER(p_vote_outcome) = 'no' THEN
        v_vote_outcome_bool := FALSE;
    ELSIF LOWER(p_vote_outcome) = 'cancel' THEN
        v_vote_outcome_bool := NULL;
    ELSE
        RETURN jsonb_build_object('success', false, 'error', 'Invalid vote outcome. Must be yes, no, or cancel');
    END IF;

    -- Get contest details
    SELECT * INTO v_contest FROM settlement_contests WHERE id = p_contest_id;
    IF NOT FOUND THEN
        RETURN jsonb_build_object('success', false, 'error', 'Contest not found');
    END IF;

    -- Get market details
    SELECT * INTO v_market FROM markets WHERE id = v_contest.market_id;
    IF NOT FOUND THEN
        RETURN jsonb_build_object('success', false, 'error', 'Market not found');
    END IF;

    -- Check if contest is still in voting period
    IF v_market.settlement_status != 'contested' THEN
        RETURN jsonb_build_object('success', false, 'error', 'Contest is not in voting period');
    END IF;

    -- Check if voter has already voted
    IF EXISTS (SELECT 1 FROM settlement_votes WHERE contest_id = p_contest_id AND voter_id = p_voter_id) THEN
        RETURN jsonb_build_object('success', false, 'error', 'You have already voted on this contest');
    END IF;

    -- Use profiles table instead of users
    -- Check voter balance
    SELECT balance INTO v_voter_balance FROM profiles WHERE id = p_voter_id;
    IF v_voter_balance IS NULL OR v_voter_balance < v_vote_bond_amount THEN
        RETURN jsonb_build_object('success', false, 'error', 'Insufficient balance. Vote bond requires $' || v_vote_bond_amount);
    END IF;

    -- Use profiles table instead of users
    -- Deduct vote bond from user balance
    UPDATE profiles SET balance = balance - v_vote_bond_amount WHERE id = p_voter_id;

    -- Create the vote
    -- NOTE: Ledger entries are automatically created by trigger track_settlement_vote_ledger (script 290)
    INSERT INTO settlement_votes (
        contest_id,
        voter_id,
        vote_outcome,
        vote_outcome_text,
        vote_bond_amount
    ) VALUES (
        p_contest_id,
        p_voter_id,
        v_vote_outcome_bool,
        LOWER(p_vote_outcome),
        v_vote_bond_amount
    ) RETURNING id INTO v_vote_id;

    -- Create notification for vote submission
    INSERT INTO notifications (user_id, type, title, message, market_id)
    VALUES (
        p_voter_id,
        'settlement',
        'Vote Submitted',
        'Your vote of ' || UPPER(p_vote_outcome) || ' has been recorded for ""' || v_market.title || '""',
        v_market.id
    );

    RETURN jsonb_build_object(
        'success', true,
        'vote_id', v_vote_id,
        'vote_outcome', p_vote_outcome,
        'vote_bond_amount', v_vote_bond_amount,
        'market_id', v_market.id,
        'contest_id', p_contest_id
    );
END;
$function$
"
"public","sync_market_lp_from_ledger","CREATE OR REPLACE FUNCTION public.sync_market_lp_from_ledger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_market_id UUID;
  v_new_balance NUMERIC;
BEGIN
  -- Get the market_id from the ledger_account
  SELECT la.reference_id INTO v_market_id
  FROM ledger_accounts la
  WHERE la.id = NEW.account_id
    AND la.account_type = 'market_pool';
  
  -- If this is a market pool account, update the markets table
  IF v_market_id IS NOT NULL THEN
    -- Get the new balance from the snapshot
    v_new_balance := ROUND(COALESCE(NEW.balance_cents, 0) / 100.0, 4);
    
    -- Update markets.liquidity_pool to match the ledger
    UPDATE markets
    SET liquidity_pool = v_new_balance
    WHERE id = v_market_id;
    
    RAISE NOTICE 'Synced market % LP from ledger: $%', v_market_id, v_new_balance;
  END IF;
  
  RETURN NEW;
END;
$function$
"
"public","sync_market_lp_from_ledger_entry","CREATE OR REPLACE FUNCTION public.sync_market_lp_from_ledger_entry()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_market_id UUID;
  v_account_type TEXT;
  v_running_balance NUMERIC;
BEGIN
  -- Get the account type and reference_id
  SELECT la.account_type, la.reference_id 
  INTO v_account_type, v_market_id
  FROM ledger_accounts la
  WHERE la.id = NEW.account_id;
  
  -- Only process market_pool accounts
  IF v_account_type = 'market_pool' AND v_market_id IS NOT NULL THEN
    -- Calculate running balance from all ledger entries for this account
    SELECT ROUND(COALESCE(SUM(
      CASE WHEN le.entry_type = 'credit' THEN le.amount_cents
           WHEN le.entry_type = 'debit' THEN -le.amount_cents
           ELSE 0 END
    ), 0) / 100.0, 4)
    INTO v_running_balance
    FROM ledger_entries le
    WHERE le.account_id = NEW.account_id;
    
    -- Update markets.liquidity_pool
    UPDATE markets
    SET liquidity_pool = v_running_balance
    WHERE id = v_market_id;
    
    RAISE NOTICE 'Synced market % LP from ledger entry: $%', v_market_id, v_running_balance;
  END IF;
  
  RETURN NEW;
END;
$function$
"
"public","sync_profile_balance_from_ledger","CREATE OR REPLACE FUNCTION public.sync_profile_balance_from_ledger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_user_id UUID;
  v_account_type TEXT;
BEGIN
  -- Get the account type and reference_id (user_id) from ledger_accounts
  SELECT account_type, reference_id 
  INTO v_account_type, v_user_id
  FROM ledger_accounts 
  WHERE id = NEW.account_id;
  
  -- Only sync for 'user' type accounts
  IF v_account_type = 'user' AND v_user_id IS NOT NULL THEN
    UPDATE profiles 
    SET balance = NEW.balance_cents / 100.0
    WHERE id = v_user_id;
    
    RAISE NOTICE '[Ledger Sync] Updated profiles.balance for user % to $%', 
      v_user_id, NEW.balance_cents / 100.0;
  END IF;
  
  RETURN NEW;
END;
$function$
"
"public","track_bond_balance_updates","CREATE OR REPLACE FUNCTION public.track_bond_balance_updates()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- For settlement_bonds: when balance is credited back, set payout_amount
  IF TG_TABLE_NAME = 'settlement_bonds' THEN
    IF NEW.status = 'returned' AND (OLD.payout_amount IS NULL OR OLD.payout_amount = 0) THEN
      NEW.payout_amount := NEW.bond_amount;
    END IF;
  END IF;
  
  -- For settlement_contests: when status changes to resolved, calculate payout
  IF TG_TABLE_NAME = 'settlement_contests' THEN
    IF NEW.status = 'resolved' AND NEW.resolution_outcome IS NOT NULL 
       AND (OLD.payout_amount IS NULL OR OLD.payout_amount = 0) THEN
      -- Winner gets their bond back plus potentially more from pool
      NEW.payout_amount := NEW.contest_bond_amount;
    END IF;
  END IF;
  
  -- For settlement_votes: when is_correct is set, calculate payout
  IF TG_TABLE_NAME = 'settlement_votes' THEN
    IF NEW.is_correct = TRUE AND (OLD.payout_amount IS NULL OR OLD.payout_amount = 0) THEN
      -- Correct voters get their bond back
      NEW.payout_amount := NEW.vote_bond_amount;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$function$
"
"public","track_closed_position","CREATE OR REPLACE FUNCTION public.track_closed_position()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_position RECORD;
  v_market RECORD;
  v_side TEXT;
  v_shares DECIMAL(20, 8);
  v_entry_price DECIMAL(20, 8);
  v_exit_price DECIMAL(20, 8);
  v_cost_basis DECIMAL(20, 8);
  v_proceeds DECIMAL(20, 8);
  v_realized_pnl DECIMAL(20, 8);
  v_close_type TEXT;
BEGIN
  -- Only process relevant transaction types
  IF NEW.type NOT IN ('sell', 'settlement_payout', 'refund') THEN
    RETURN NEW;
  END IF;
  
  -- Get market info
  SELECT id, title, status, outcome INTO v_market
  FROM markets WHERE id = NEW.market_id;
  
  IF v_market IS NULL THEN
    RETURN NEW;
  END IF;
  
  -- Determine close type and extract data based on transaction type
  IF NEW.type = 'sell' THEN
    v_close_type := 'sell';
    v_shares := COALESCE(NEW.shares, 0);
    v_exit_price := COALESCE(NEW.price_per_share, 0);
    v_cost_basis := COALESCE(NEW.cost_basis, 0);
    v_proceeds := COALESCE(NEW.amount, 0);
    v_realized_pnl := COALESCE(NEW.realized_pnl, v_proceeds - v_cost_basis);
    v_entry_price := CASE WHEN v_shares > 0 THEN v_cost_basis / v_shares ELSE 0 END;
    
    -- Determine side from transaction
    IF NEW.side IS NOT NULL THEN
      v_side := CASE 
        WHEN NEW.side::TEXT IN ('true', 'YES', 'yes', 'Yes') THEN 'yes'
        ELSE 'no'
      END;
    ELSE
      -- Try to get from position
      SELECT side INTO v_side FROM positions WHERE user_id = NEW.user_id AND market_id = NEW.market_id LIMIT 1;
      v_side := CASE WHEN v_side::TEXT IN ('true', 'YES', 'yes', 'Yes', 't') THEN 'yes' ELSE 'no' END;
    END IF;
    
  ELSIF NEW.type = 'settlement_payout' THEN
    -- Settlement payout - could be win or loss
    -- Get position info to determine if win or loss
    SELECT p.side, p.shares, p.avg_price, p.amount_invested 
    INTO v_position
    FROM positions p
    WHERE p.user_id = NEW.user_id AND p.market_id = NEW.market_id;
    
    IF v_position IS NULL THEN
      -- No position found, skip
      RETURN NEW;
    END IF;
    
    v_side := CASE WHEN v_position.side::TEXT IN ('true', 'YES', 'yes', 'Yes', 't') THEN 'yes' ELSE 'no' END;
    v_shares := COALESCE(NEW.shares, v_position.shares);
    v_entry_price := v_position.avg_price;
    v_cost_basis := v_position.amount_invested;
    v_proceeds := COALESCE(NEW.amount, 0);
    v_realized_pnl := v_proceeds - v_cost_basis;
    
    -- Determine if this is a win or loss based on proceeds
    IF v_proceeds > v_cost_basis THEN
      v_close_type := 'settlement_win';
      v_exit_price := 1.0; -- Winner gets $1 per share
    ELSIF v_proceeds > 0 THEN
      v_close_type := 'settlement_win';
      v_exit_price := v_proceeds / NULLIF(v_shares, 0);
    ELSE
      v_close_type := 'settlement_loss';
      v_exit_price := 0.0; -- Loser gets $0 per share
    END IF;
    
  ELSIF NEW.type = 'refund' THEN
    -- Cancellation refund - effectively break-even close
    v_close_type := 'cancellation_refund';
    
    -- Get position info
    SELECT p.side, p.shares, p.avg_price, p.amount_invested 
    INTO v_position
    FROM positions p
    WHERE p.user_id = NEW.user_id AND p.market_id = NEW.market_id;
    
    IF v_position IS NULL THEN
      -- No position found, skip
      RETURN NEW;
    END IF;
    
    v_side := CASE WHEN v_position.side::TEXT IN ('true', 'YES', 'yes', 'Yes', 't') THEN 'yes' ELSE 'no' END;
    v_shares := v_position.shares;
    v_entry_price := v_position.avg_price;
    v_exit_price := v_position.avg_price; -- Refund at entry price (break-even)
    v_cost_basis := v_position.amount_invested;
    v_proceeds := COALESCE(NEW.amount, v_cost_basis);
    v_realized_pnl := 0; -- Cancellation = break-even
  END IF;
  
  -- Insert closed position record
  INSERT INTO closed_positions (
    user_id,
    market_id,
    side,
    shares,
    entry_price,
    exit_price,
    cost_basis,
    proceeds,
    realized_pnl,
    close_type,
    transaction_id,
    market_title,
    market_status,
    market_outcome
  ) VALUES (
    NEW.user_id,
    NEW.market_id,
    v_side,
    v_shares,
    v_entry_price,
    v_exit_price,
    v_cost_basis,
    v_proceeds,
    v_realized_pnl,
    v_close_type,
    NEW.id,
    v_market.title,
    v_market.status,
    v_market.outcome
  );
  
  RETURN NEW;
END;
$function$
"
"public","track_deposit_withdrawal_to_ledger","CREATE OR REPLACE FUNCTION public.track_deposit_withdrawal_to_ledger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_user_account_id UUID;
    v_clearing_account_id UUID;
    v_amount_cents BIGINT;
BEGIN
    -- Only handle deposit/withdrawal
    IF NEW.type NOT IN ('deposit', 'withdraw') THEN
        RETURN NEW;
    END IF;
    
    v_amount_cents := (NEW.amount * 100)::BIGINT;
    
    RAISE NOTICE '[Ledger] Processing %: amount=$%, user=%', NEW.type, NEW.amount, NEW.user_id;
    
    -- Get or create accounts
    v_user_account_id := get_or_create_account(NEW.user_id, 'user');
    v_clearing_account_id := get_or_create_account(
        '00000000-0000-0000-0000-00000000C1EA'::UUID,
        'external_clearing'
    );
    
    IF NEW.type = 'deposit' THEN
        -- Deposit: Credit user, Debit clearing
        -- Use NULL for transaction_id since deposit_withdraw.id is integer, not UUID
        PERFORM create_ledger_entry(
            v_user_account_id,
            'credit',
            v_amount_cents,
            'deposit',
            NULL, -- transaction_id is NULL for deposits
            NEW.user_id,
            NULL,
            'Deposit from external clearing account',
            jsonb_build_object('deposit_withdraw_id', NEW.id)
        );
        
        PERFORM create_ledger_entry(
            v_clearing_account_id,
            'debit',
            v_amount_cents,
            'deposit',
            NULL, -- transaction_id is NULL for deposits
            NEW.user_id,
            NULL,
            'Money leaving clearing account (deposit)',
            jsonb_build_object('deposit_withdraw_id', NEW.id)
        );
        
        RAISE NOTICE '[Ledger] Deposit tracked successfully';
        
    ELSIF NEW.type = 'withdraw' THEN
        -- Withdrawal: Debit user, Credit clearing
        -- Use NULL for transaction_id since deposit_withdraw.id is integer, not UUID
        PERFORM create_ledger_entry(
            v_user_account_id,
            'debit',
            v_amount_cents,
            'withdrawal',
            NULL, -- transaction_id is NULL for withdrawals
            NEW.user_id,
            NULL,
            'Withdrawal to external clearing account',
            jsonb_build_object('deposit_withdraw_id', NEW.id)
        );
        
        PERFORM create_ledger_entry(
            v_clearing_account_id,
            'credit',
            v_amount_cents,
            'withdrawal',
            NULL, -- transaction_id is NULL for withdrawals
            NEW.user_id,
            NULL,
            'Money arriving at clearing account (withdrawal)',
            jsonb_build_object('deposit_withdraw_id', NEW.id)
        );
        
        RAISE NOTICE '[Ledger] Withdrawal tracked successfully';
    END IF;
    
    RETURN NEW;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '[Ledger] Error tracking deposit/withdrawal: %', SQLERRM;
        RETURN NEW;
END;
$function$
"
"public","track_liquidity_sweep","CREATE OR REPLACE FUNCTION public.track_liquidity_sweep()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_current_platform_balance NUMERIC;
BEGIN
    -- Process both platform_fee and liquidity_sweep type transactions
    -- Added 'liquidity_sweep' to the type check since that's what settlement creates
    IF NEW.type NOT IN ('platform_fee', 'liquidity_sweep') THEN
        RETURN NEW;
    END IF;

    -- Get current platform balance
    SELECT COALESCE(SUM(amount), 0) INTO v_current_platform_balance
    FROM platform_ledger;

    -- Insert into platform_ledger
    -- For liquidity_sweep, amount is positive (income for platform)
    -- For platform_fee, amount may be negative, so we use ABS
    INSERT INTO platform_ledger (
        id,
        transaction_type,
        amount,
        balance_after,
        market_id,
        related_transaction_id,
        metadata,
        created_at
    ) VALUES (
        gen_random_uuid(),
        'settlement_leftover',
        ABS(NEW.amount),
        v_current_platform_balance + ABS(NEW.amount),
        NEW.market_id,
        NEW.id,
        jsonb_build_object(
            'user_id', NEW.user_id,
            'description', NEW.description,
            'source', CASE WHEN NEW.type = 'liquidity_sweep' THEN 'liquidity_sweep' ELSE 'platform_fee' END
        ),
        NOW()
    );

    RETURN NEW;
END;
$function$
"
"public","track_market_creation_to_ledger","CREATE OR REPLACE FUNCTION public.track_market_creation_to_ledger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_user_account_id UUID;
    v_pool_account_id UUID;
    v_platform_account_id UUID;
    v_amount_cents BIGINT;
    v_platform_fee_cents BIGINT := 1000;  -- $10 in cents
    v_pool_amount_cents BIGINT;
    v_is_private BOOLEAN;
BEGIN
    -- Only track market creation transactions
    IF NEW.type != 'market_creation' OR NEW.market_id IS NULL THEN
        RETURN NEW;
    END IF;
    
    -- Convert amount to cents EXACTLY like deposits/withdrawals do
    -- Transaction amount is negative (e.g., -50.00), convert to positive cents (5000)
    v_amount_cents := (ABS(NEW.amount) * 100)::BIGINT;
    
    RAISE NOTICE '[Ledger] Processing market creation: market=%, amount=$% (% cents), user=%',
        NEW.market_id, ABS(NEW.amount), v_amount_cents, NEW.user_id;
    
    -- Get or create accounts
    v_user_account_id := get_or_create_account(NEW.user_id, 'user');
    v_pool_account_id := get_or_create_account(NEW.market_id, 'market_pool');
    
    -- Check if market is private or public
    SELECT is_private INTO v_is_private FROM markets WHERE id = NEW.market_id;
    
    IF v_is_private = FALSE THEN
        -- PUBLIC MARKET: $10 to platform, rest to pool
        v_pool_amount_cents := v_amount_cents - v_platform_fee_cents;
        v_platform_account_id := get_or_create_account(
            '00000000-0000-0000-0000-000000000000'::UUID,
            'platform'
        );
        
        -- Debit user for full amount
        PERFORM create_ledger_entry(
            v_user_account_id,
            'debit',
            v_amount_cents,
            'market_creation',
            NEW.id,
            NEW.user_id,
            NEW.market_id,
            FORMAT('Public market creation - Total: $%s', v_amount_cents / 100.0),
            jsonb_build_object('market_id', NEW.market_id, 'is_private', FALSE)
        );
        
        -- Credit platform $10
        PERFORM create_ledger_entry(
            v_platform_account_id,
            'credit',
            v_platform_fee_cents,
            'market_creation',
            NEW.id,
            NEW.user_id,
            NEW.market_id,
            'Platform fee for public market creation ($10)',
            jsonb_build_object('market_id', NEW.market_id, 'fee_type', 'market_creation')
        );
        
        -- Credit pool with remaining amount
        PERFORM create_ledger_entry(
            v_pool_account_id,
            'credit',
            v_pool_amount_cents,
            'market_creation',
            NEW.id,
            NEW.user_id,
            NEW.market_id,
            FORMAT('Initial liquidity for market pool: $%s', v_pool_amount_cents / 100.0),
            jsonb_build_object('market_id', NEW.market_id, 'liquidity_type', 'initial')
        );
        
        RAISE NOTICE '[Ledger] Public market: $% total ($10 platform, $% pool)',
            v_amount_cents / 100.0, v_pool_amount_cents / 100.0;
            
    ELSE
        -- PRIVATE MARKET: Full amount to pool
        -- Debit user for full amount
        PERFORM create_ledger_entry(
            v_user_account_id,
            'debit',
            v_amount_cents,
            'market_creation',
            NEW.id,
            NEW.user_id,
            NEW.market_id,
            FORMAT('Private market creation - Total: $%s', v_amount_cents / 100.0),
            jsonb_build_object('market_id', NEW.market_id, 'is_private', TRUE)
        );
        
        -- Credit pool with full amount
        PERFORM create_ledger_entry(
            v_pool_account_id,
            'credit',
            v_amount_cents,
            'market_creation',
            NEW.id,
            NEW.user_id,
            NEW.market_id,
            FORMAT('Initial liquidity for private market pool: $%s', v_amount_cents / 100.0),
            jsonb_build_object('market_id', NEW.market_id, 'liquidity_type', 'initial')
        );
        
        RAISE NOTICE '[Ledger] Private market: $% to pool', v_amount_cents / 100.0;
    END IF;
    
    RETURN NEW;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '[Ledger] Error tracking market creation: %', SQLERRM;
        RETURN NEW;
END;
$function$
"
"public","track_platform_fees","CREATE OR REPLACE FUNCTION public.track_platform_fees()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_current_platform_balance NUMERIC;
    v_fee_amount NUMERIC;
BEGIN
    -- Only process 'buy' and 'sell' transactions
    IF NEW.type NOT IN ('buy', 'sell') THEN
        RETURN NEW;
    END IF;

    -- Skip fee tracking for zero-amount transactions
    IF NEW.amount IS NULL OR NEW.amount = 0 THEN
        RETURN NEW;
    END IF;

    -- Calculate platform fee (0.5% of trade amount)
    v_fee_amount := NEW.amount * 0.005;

    -- Get current platform balance
    SELECT COALESCE(SUM(amount), 0) INTO v_current_platform_balance
    FROM platform_ledger;

    -- Insert platform fee into platform_ledger
    INSERT INTO platform_ledger (
        id,
        transaction_type,
        amount,
        balance_after,
        market_id,
        related_transaction_id,
        metadata,
        created_at
    ) VALUES (
        gen_random_uuid(),
        'platform_fee',
        v_fee_amount,
        v_current_platform_balance + v_fee_amount,
        NEW.market_id,
        NEW.id,
        jsonb_build_object(
            'user_id', NEW.user_id,
            'transaction_type', NEW.type,
            'original_amount', NEW.amount,
            'fee_percentage', 0.005,
            'description', 'Platform fee (0.5%) from ' || NEW.type || ' trade'
        ),
        NOW()
    );

    RETURN NEW;
END;
$function$
"
"public","track_settlement_bond_to_ledger","CREATE OR REPLACE FUNCTION public.track_settlement_bond_to_ledger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_creator_fees_account_id UUID;
    v_bond_account_id UUID;
    v_amount_cents BIGINT;
BEGIN
    -- Only track on INSERT
    IF TG_OP != 'INSERT' THEN
        RETURN NEW;
    END IF;
    
    -- Skip if bond amount is 0 or NULL
    IF COALESCE(NEW.bond_amount, 0) <= 0 THEN
        RAISE NOTICE '[Bond Ledger] Skipping bond with zero/null amount';
        RETURN NEW;
    END IF;
    
    v_amount_cents := (NEW.bond_amount * 100)::BIGINT;
    
    RAISE NOTICE '[Bond Ledger] Tracking settlement bond: market=%, creator=%, amount=$%',
        NEW.market_id, NEW.creator_id, NEW.bond_amount;
    
    -- Get or create the market_creator_fees account (source of bond)
    v_creator_fees_account_id := get_or_create_account(NEW.market_id, 'market_creator_fees');
    
    -- Get or create the settlement_bond account (destination)
    v_bond_account_id := get_or_create_account(NEW.market_id, 'settlement_bond');
    
    -- DEBIT market_creator_fees (fees are used as the bond)
    PERFORM create_ledger_entry(
        v_creator_fees_account_id,
        'debit',
        v_amount_cents,
        'settlement_bond',
        NULL::UUID,  -- no transaction_id
        NEW.creator_id,
        NEW.market_id,
        FORMAT('Settlement bond posted from creator fees: $%s', NEW.bond_amount),
        jsonb_build_object('bond_id', NEW.id, 'bond_type', 'settlement')
    );
    
    -- CREDIT settlement_bond account
    PERFORM create_ledger_entry(
        v_bond_account_id,
        'credit',
        v_amount_cents,
        'settlement_bond',
        NULL::UUID,
        NEW.creator_id,
        NEW.market_id,
        FORMAT('Settlement bond received: $%s', NEW.bond_amount),
        jsonb_build_object('bond_id', NEW.id, 'bond_type', 'settlement')
    );
    
    RAISE NOTICE '[Bond Ledger] Settlement bond tracked successfully';
    
    RETURN NEW;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '[Bond Ledger] Error tracking settlement bond: %', SQLERRM;
        RETURN NEW;
END;
$function$
"
"public","track_settlement_contest_to_ledger","CREATE OR REPLACE FUNCTION public.track_settlement_contest_to_ledger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_user_account_id UUID;
    v_contest_bond_account_id UUID;
    v_amount_cents BIGINT;
BEGIN
    -- Only track on INSERT
    IF TG_OP != 'INSERT' THEN
        RETURN NEW;
    END IF;
    
    -- Skip if bond amount is 0 or NULL
    IF COALESCE(NEW.contest_bond_amount, 0) <= 0 THEN
        RAISE NOTICE '[Contest Ledger] Skipping contest with zero/null amount';
        RETURN NEW;
    END IF;
    
    v_amount_cents := (NEW.contest_bond_amount * 100)::BIGINT;
    
    RAISE NOTICE '[Contest Ledger] Tracking settlement contest: market=%, contestant=%, amount=$%',
        NEW.market_id, NEW.contestant_id, NEW.contest_bond_amount;
    
    -- Get user account (user pays for the contest bond)
    v_user_account_id := get_or_create_account(NEW.contestant_id, 'user');
    
    -- Get or create contest_bond account for this market
    v_contest_bond_account_id := get_or_create_account(NEW.market_id, 'contest_bond');
    
    -- DEBIT user balance (user pays)
    PERFORM create_ledger_entry(
        v_user_account_id,
        'debit',
        v_amount_cents,
        'contest_bond',
        NULL::UUID,
        NEW.contestant_id,
        NEW.market_id,
        FORMAT('Contest bond posted: $%s', NEW.contest_bond_amount),
        jsonb_build_object('contest_id', NEW.id, 'bond_type', 'contest')
    );
    
    -- CREDIT contest_bond account
    PERFORM create_ledger_entry(
        v_contest_bond_account_id,
        'credit',
        v_amount_cents,
        'contest_bond',
        NULL::UUID,
        NEW.contestant_id,
        NEW.market_id,
        FORMAT('Contest bond received: $%s', NEW.contest_bond_amount),
        jsonb_build_object('contest_id', NEW.id, 'bond_type', 'contest')
    );
    
    RAISE NOTICE '[Contest Ledger] Contest bond tracked successfully';
    
    RETURN NEW;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '[Contest Ledger] Error tracking contest bond: %', SQLERRM;
        RETURN NEW;
END;
$function$
"
"public","track_settlement_to_ledger","CREATE OR REPLACE FUNCTION public.track_settlement_to_ledger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_user_account_id UUID;
    v_pool_account_id UUID;
    v_creator_fees_account_id UUID;
    v_platform_account_id UUID;
    v_amount_cents BIGINT;
BEGIN
    -- REMOVED bond_payout from this list - it's handled by payout_bonds_to_ledger directly
    -- REMOVED refund - not currently used or if used, should be handled elsewhere
    IF NEW.type NOT IN ('settlement_payout', 'creator_payout', 'liquidity_return', 'liquidity_sweep') THEN
        RETURN NEW;
    END IF;
    
    v_amount_cents := (ABS(NEW.amount) * 100)::BIGINT;
    
    -- Get or create accounts
    v_user_account_id := get_or_create_account(NEW.user_id, 'user');
    v_pool_account_id := get_or_create_account(NEW.market_id, 'market_pool');
    v_creator_fees_account_id := get_or_create_account(NEW.market_id, 'market_creator_fees');
    v_platform_account_id := get_or_create_account(
        '00000000-0000-0000-0000-000000000000'::UUID,
        'platform'
    );
    
    IF NEW.type = 'settlement_payout' THEN
        -- Settlement payout: Debit pool, Credit user
        PERFORM create_ledger_entry(
            v_pool_account_id,
            'debit',
            v_amount_cents,
            'settlement_payout',
            NEW.id,
            NEW.user_id,
            NEW.market_id,
            FORMAT('Settlement payout to winner: $%s', NEW.amount),
            jsonb_build_object('payout_type', 'settlement')
        );
        
        PERFORM create_ledger_entry(
            v_user_account_id,
            'credit',
            v_amount_cents,
            'settlement_payout',
            NEW.id,
            NEW.user_id,
            NEW.market_id,
            FORMAT('Settlement payout received: $%s', NEW.amount),
            jsonb_build_object('payout_type', 'settlement')
        );
        
    ELSIF NEW.type = 'creator_payout' THEN
        -- Creator fee payout: Debit creator fees account, Credit user (creator)
        PERFORM create_ledger_entry(
            v_creator_fees_account_id,
            'debit',
            v_amount_cents,
            'creator_payout',
            NEW.id,
            NEW.user_id,
            NEW.market_id,
            FORMAT('Creator fee payout: $%s', NEW.amount),
            jsonb_build_object('payout_type', 'creator_fees')
        );
        
        PERFORM create_ledger_entry(
            v_user_account_id,
            'credit',
            v_amount_cents,
            'creator_payout',
            NEW.id,
            NEW.user_id,
            NEW.market_id,
            FORMAT('Creator fee payout received: $%s', NEW.amount),
            jsonb_build_object('payout_type', 'creator_fees')
        );
        
    ELSIF NEW.type = 'liquidity_return' THEN
        -- Liquidity return: Debit pool, Credit user (creator)
        PERFORM create_ledger_entry(
            v_pool_account_id,
            'debit',
            v_amount_cents,
            'liquidity_return',
            NEW.id,
            NEW.user_id,
            NEW.market_id,
            FORMAT('Liquidity returned to creator: $%s', NEW.amount),
            jsonb_build_object('return_type', 'liquidity')
        );
        
        PERFORM create_ledger_entry(
            v_user_account_id,
            'credit',
            v_amount_cents,
            'liquidity_return',
            NEW.id,
            NEW.user_id,
            NEW.market_id,
            FORMAT('Liquidity returned: $%s', NEW.amount),
            jsonb_build_object('return_type', 'liquidity')
        );
        
    ELSIF NEW.type = 'liquidity_sweep' THEN
        -- Platform liquidity sweep: Debit pool, Credit platform
        PERFORM create_ledger_entry(
            v_pool_account_id,
            'debit',
            v_amount_cents,
            'liquidity_sweep',
            NEW.id,
            NEW.user_id,
            NEW.market_id,
            FORMAT('Remaining liquidity swept to platform: $%s', NEW.amount),
            jsonb_build_object('sweep_type', 'platform')
        );
        
        PERFORM create_ledger_entry(
            v_platform_account_id,
            'credit',
            v_amount_cents,
            'liquidity_sweep',
            NEW.id,
            NEW.user_id,
            NEW.market_id,
            FORMAT('Platform liquidity sweep: $%s', NEW.amount),
            jsonb_build_object('sweep_type', 'platform')
        );
    END IF;
    
    RETURN NEW;
END;
$function$
"
"public","track_settlement_vote_to_ledger","CREATE OR REPLACE FUNCTION public.track_settlement_vote_to_ledger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_user_account_id UUID;
    v_vote_bond_account_id UUID;
    v_amount_cents BIGINT;
    v_market_id UUID;
BEGIN
    -- Only track on INSERT
    IF TG_OP != 'INSERT' THEN
        RETURN NEW;
    END IF;
    
    -- Skip if bond amount is 0 or NULL
    IF COALESCE(NEW.vote_bond_amount, 0) <= 0 THEN
        RAISE NOTICE '[Vote Ledger] Skipping vote with zero/null amount';
        RETURN NEW;
    END IF;
    
    v_amount_cents := (NEW.vote_bond_amount * 100)::BIGINT;
    
    -- Get market_id from the contest
    SELECT market_id INTO v_market_id
    FROM settlement_contests
    WHERE id = NEW.contest_id;
    
    RAISE NOTICE '[Vote Ledger] Tracking settlement vote: contest=%, voter=%, amount=$%',
        NEW.contest_id, NEW.voter_id, NEW.vote_bond_amount;
    
    -- Get user account (user pays for the vote bond)
    v_user_account_id := get_or_create_account(NEW.voter_id, 'user');
    
    -- Get or create vote_bond account for this market
    v_vote_bond_account_id := get_or_create_account(v_market_id, 'vote_bond');
    
    -- DEBIT user balance (user pays)
    PERFORM create_ledger_entry(
        v_user_account_id,
        'debit',
        v_amount_cents,
        'vote_bond',
        NULL::UUID,
        NEW.voter_id,
        v_market_id,
        FORMAT('Vote bond posted: $%s', NEW.vote_bond_amount),
        jsonb_build_object('vote_id', NEW.id, 'bond_type', 'vote')
    );
    
    -- CREDIT vote_bond account
    PERFORM create_ledger_entry(
        v_vote_bond_account_id,
        'credit',
        v_amount_cents,
        'vote_bond',
        NULL::UUID,
        NEW.voter_id,
        v_market_id,
        FORMAT('Vote bond received: $%s', NEW.vote_bond_amount),
        jsonb_build_object('vote_id', NEW.id, 'bond_type', 'vote')
    );
    
    RAISE NOTICE '[Vote Ledger] Vote bond tracked successfully';
    
    RETURN NEW;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '[Vote Ledger] Error tracking vote bond: %', SQLERRM;
        RETURN NEW;
END;
$function$
"
"public","track_shares_and_liquidity","CREATE OR REPLACE FUNCTION public.track_shares_and_liquidity()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_prev_user_qy NUMERIC := 0;
  v_prev_user_qn NUMERIC := 0;
  v_prev_market_qy NUMERIC := 0;
  v_prev_market_qn NUMERIC := 0;
  v_prev_lp NUMERIC := 0;
  v_market RECORD;
  v_is_yes BOOLEAN;
  v_amount_after_fees NUMERIC;
  v_lp_debit_gross NUMERIC;
BEGIN
  -- Only process relevant transaction types
  IF NEW.type NOT IN ('buy', 'sell', 'market_creation', 'settlement_payout', 'liquidity_return', 'liquidity_sweep', 'creator_payout') THEN
    RETURN NEW;
  END IF;

  -- Get current market state for LP tracking
  SELECT liquidity_pool, qy, qn, is_private INTO v_market
  FROM markets WHERE id = NEW.market_id;

  -- Calculate amount after fees for buy transactions (1 percent fee)
  IF NEW.type = 'buy' THEN
    v_amount_after_fees := ROUND(ABS(COALESCE(NEW.amount, 0)) * 0.99, 4);
  ELSE
    v_amount_after_fees := ROUND(ABS(COALESCE(NEW.amount, 0)), 4);
  END IF;

  -- For sell transactions, calculate gross LP debit (amount / 0.99)
  IF NEW.type = 'sell' THEN
    v_lp_debit_gross := ROUND(ABS(COALESCE(NEW.amount, 0)) / 0.99, 4);
  ELSE
    v_lp_debit_gross := ROUND(ABS(COALESCE(NEW.amount, 0)), 4);
  END IF;

  -- Get previous user share balances for this user/market
  SELECT user_qy, user_qn INTO v_prev_user_qy, v_prev_user_qn
  FROM transactions
  WHERE user_id = NEW.user_id
    AND market_id = NEW.market_id
    AND id != NEW.id
  ORDER BY created_at DESC
  LIMIT 1;

  v_prev_user_qy := COALESCE(v_prev_user_qy, 0);
  v_prev_user_qn := COALESCE(v_prev_user_qn, 0);

  -- Get previous market share balances and LP balance
  SELECT market_qy, market_qn, market_liquidity_pool INTO v_prev_market_qy, v_prev_market_qn, v_prev_lp
  FROM transactions
  WHERE market_id = NEW.market_id
    AND id != NEW.id
  ORDER BY created_at DESC
  LIMIT 1;

  v_prev_market_qy := COALESCE(v_prev_market_qy, 0);
  v_prev_market_qn := COALESCE(v_prev_market_qn, 0);
  v_prev_lp := COALESCE(v_prev_lp, COALESCE(v_market.liquidity_pool, 0));

  -- Case-insensitive side comparison (LOWER)
  v_is_yes := (LOWER(COALESCE(NEW.side, 'yes')) = 'yes');

  -- Handle different transaction types
  IF NEW.type = 'buy' THEN
    -- User gains shares, market gains shares, LP gains amount after fees
    IF v_is_yes THEN
      NEW.user_qy := ROUND(v_prev_user_qy + COALESCE(NEW.shares, 0), 4);
      NEW.user_qn := ROUND(v_prev_user_qn, 4);
      NEW.user_qy_credit := ROUND(COALESCE(NEW.shares, 0), 4);
      NEW.user_qy_debit := 0;
      NEW.user_qn_credit := 0;
      NEW.user_qn_debit := 0;
      NEW.market_qy := ROUND(v_prev_market_qy + COALESCE(NEW.shares, 0), 4);
      NEW.market_qn := ROUND(v_prev_market_qn, 4);
      NEW.qy_credit := ROUND(COALESCE(NEW.shares, 0), 4);
      NEW.qy_debit := 0;
      NEW.qn_credit := 0;
      NEW.qn_debit := 0;
    ELSE
      NEW.user_qy := ROUND(v_prev_user_qy, 4);
      NEW.user_qn := ROUND(v_prev_user_qn + COALESCE(NEW.shares, 0), 4);
      NEW.user_qy_credit := 0;
      NEW.user_qy_debit := 0;
      NEW.user_qn_credit := ROUND(COALESCE(NEW.shares, 0), 4);
      NEW.user_qn_debit := 0;
      NEW.market_qy := ROUND(v_prev_market_qy, 4);
      NEW.market_qn := ROUND(v_prev_market_qn + COALESCE(NEW.shares, 0), 4);
      NEW.qy_credit := 0;
      NEW.qy_debit := 0;
      NEW.qn_credit := ROUND(COALESCE(NEW.shares, 0), 4);
      NEW.qn_debit := 0;
    END IF;
    -- LP credit uses amount after fees (amount * 0.99)
    NEW.market_liquidity_pool := ROUND(v_prev_lp + v_amount_after_fees, 4);
    NEW.lp_credit := v_amount_after_fees;
    NEW.lp_debit := 0;

  ELSIF NEW.type = 'sell' THEN
    -- User loses shares, market loses shares, LP debits gross payout (amount / 0.99)
    IF v_is_yes THEN
      NEW.user_qy := ROUND(v_prev_user_qy - COALESCE(NEW.shares, 0), 4);
      NEW.user_qn := ROUND(v_prev_user_qn, 4);
      NEW.user_qy_credit := 0;
      NEW.user_qy_debit := ROUND(COALESCE(NEW.shares, 0), 4);
      NEW.user_qn_credit := 0;
      NEW.user_qn_debit := 0;
      NEW.market_qy := ROUND(v_prev_market_qy - COALESCE(NEW.shares, 0), 4);
      NEW.market_qn := ROUND(v_prev_market_qn, 4);
      NEW.qy_credit := 0;
      NEW.qy_debit := ROUND(COALESCE(NEW.shares, 0), 4);
      NEW.qn_credit := 0;
      NEW.qn_debit := 0;
    ELSE
      NEW.user_qy := ROUND(v_prev_user_qy, 4);
      NEW.user_qn := ROUND(v_prev_user_qn - COALESCE(NEW.shares, 0), 4);
      NEW.user_qy_credit := 0;
      NEW.user_qy_debit := 0;
      NEW.user_qn_credit := 0;
      NEW.user_qn_debit := ROUND(COALESCE(NEW.shares, 0), 4);
      NEW.market_qy := ROUND(v_prev_market_qy, 4);
      NEW.market_qn := ROUND(v_prev_market_qn - COALESCE(NEW.shares, 0), 4);
      NEW.qy_credit := 0;
      NEW.qy_debit := 0;
      NEW.qn_credit := 0;
      NEW.qn_debit := ROUND(COALESCE(NEW.shares, 0), 4);
    END IF;
    -- LP debit uses gross amount (amount / 0.99)
    NEW.market_liquidity_pool := ROUND(v_prev_lp - v_lp_debit_gross, 4);
    NEW.lp_credit := 0;
    NEW.lp_debit := v_lp_debit_gross;

  ELSIF NEW.type = 'market_creation' THEN
    -- Market creation credits LP with initial liquidity (from markets table)
    NEW.user_qy := 0;
    NEW.user_qn := 0;
    NEW.user_qy_credit := 0;
    NEW.user_qy_debit := 0;
    NEW.user_qn_credit := 0;
    NEW.user_qn_debit := 0;
    NEW.market_qy := 0;
    NEW.market_qn := 0;
    NEW.qy_credit := 0;
    NEW.qy_debit := 0;
    NEW.qn_credit := 0;
    NEW.qn_debit := 0;
    NEW.market_liquidity_pool := COALESCE(v_market.liquidity_pool, 0);
    NEW.lp_credit := COALESCE(v_market.liquidity_pool, 0);
    NEW.lp_debit := 0;

  ELSIF NEW.type = 'settlement_payout' THEN
    -- Settlement redeems shares and debits LP
    IF v_is_yes THEN
      NEW.user_qy := ROUND(v_prev_user_qy - COALESCE(NEW.shares, 0), 4);
      NEW.user_qn := ROUND(v_prev_user_qn, 4);
      NEW.user_qy_credit := 0;
      NEW.user_qy_debit := ROUND(COALESCE(NEW.shares, 0), 4);
      NEW.user_qn_credit := 0;
      NEW.user_qn_debit := 0;
      NEW.market_qy := ROUND(v_prev_market_qy - COALESCE(NEW.shares, 0), 4);
      NEW.market_qn := ROUND(v_prev_market_qn, 4);
      NEW.qy_credit := 0;
      NEW.qy_debit := ROUND(COALESCE(NEW.shares, 0), 4);
      NEW.qn_credit := 0;
      NEW.qn_debit := 0;
    ELSE
      NEW.user_qy := ROUND(v_prev_user_qy, 4);
      NEW.user_qn := ROUND(v_prev_user_qn - COALESCE(NEW.shares, 0), 4);
      NEW.user_qy_credit := 0;
      NEW.user_qy_debit := 0;
      NEW.user_qn_credit := 0;
      NEW.user_qn_debit := ROUND(COALESCE(NEW.shares, 0), 4);
      NEW.market_qy := ROUND(v_prev_market_qy, 4);
      NEW.market_qn := ROUND(v_prev_market_qn - COALESCE(NEW.shares, 0), 4);
      NEW.qy_credit := 0;
      NEW.qy_debit := 0;
      NEW.qn_credit := 0;
      NEW.qn_debit := ROUND(COALESCE(NEW.shares, 0), 4);
    END IF;
    NEW.market_liquidity_pool := ROUND(v_prev_lp - ABS(COALESCE(NEW.amount, 0)), 4);
    NEW.lp_credit := 0;
    NEW.lp_debit := ROUND(ABS(COALESCE(NEW.amount, 0)), 4);

  ELSIF NEW.type IN ('liquidity_return', 'liquidity_sweep') THEN
    -- These affect LP (debit), but NOT creator_payout
    NEW.user_qy := ROUND(v_prev_user_qy, 4);
    NEW.user_qn := ROUND(v_prev_user_qn, 4);
    NEW.user_qy_credit := 0;
    NEW.user_qy_debit := 0;
    NEW.user_qn_credit := 0;
    NEW.user_qn_debit := 0;
    NEW.market_qy := ROUND(v_prev_market_qy, 4);
    NEW.market_qn := ROUND(v_prev_market_qn, 4);
    NEW.qy_credit := 0;
    NEW.qy_debit := 0;
    NEW.qn_credit := 0;
    NEW.qn_debit := 0;
    NEW.market_liquidity_pool := ROUND(v_prev_lp - ABS(COALESCE(NEW.amount, 0)), 4);
    NEW.lp_credit := 0;
    NEW.lp_debit := ROUND(ABS(COALESCE(NEW.amount, 0)), 4);

  ELSIF NEW.type = 'creator_payout' THEN
    -- Creator payout does NOT affect LP - fees come from separate account
    NEW.user_qy := ROUND(v_prev_user_qy, 4);
    NEW.user_qn := ROUND(v_prev_user_qn, 4);
    NEW.user_qy_credit := 0;
    NEW.user_qy_debit := 0;
    NEW.user_qn_credit := 0;
    NEW.user_qn_debit := 0;
    NEW.market_qy := ROUND(v_prev_market_qy, 4);
    NEW.market_qn := ROUND(v_prev_market_qn, 4);
    NEW.qy_credit := 0;
    NEW.qy_debit := 0;
    NEW.qn_credit := 0;
    NEW.qn_debit := 0;
    -- LP stays unchanged - creator fees come from separate ledger account
    NEW.market_liquidity_pool := ROUND(v_prev_lp, 4);
    NEW.lp_credit := 0;
    NEW.lp_debit := 0;
  END IF;

  RETURN NEW;
END;
$function$
"
"public","track_trade_fees","CREATE OR REPLACE FUNCTION public.track_trade_fees()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_market RECORD;
    v_fee_amount NUMERIC;
    v_creator_fee NUMERIC;
    v_platform_fee NUMERIC;
    v_current_platform_balance NUMERIC;
BEGIN
    -- Only process buy/sell transactions
    IF NEW.type NOT IN ('buy', 'sell') THEN
        RETURN NEW;
    END IF;
    
    -- Get market info
    SELECT * INTO v_market FROM markets WHERE id = NEW.market_id;
    IF NOT FOUND THEN
        RETURN NEW;
    END IF;
    
    -- Calculate fees (2% of transaction, split 50/50)
    v_fee_amount := ABS(NEW.amount) * 0.02;
    v_creator_fee := v_fee_amount * 0.5;
    v_platform_fee := v_fee_amount * 0.5;
    
    -- Create ledger entries for creator fee (this will trigger update_creator_fees_from_ledger)
    -- Debit from market pool
    INSERT INTO ledger_entries (user_id, account_type, account_ref_id, amount, entry_type, description)
    VALUES (NEW.user_id, 'market_pool', NEW.market_id, -v_creator_fee, 'trade_fee', 'Creator fee from trade');
    
    -- Credit to creator fees account (this triggers the column update)
    INSERT INTO ledger_entries (user_id, account_type, account_ref_id, amount, entry_type, description)
    VALUES (v_market.creator_id, 'creator_fees', NEW.market_id, v_creator_fee, 'trade_fee', 'Creator fee earned from trade');
    
    -- Removed: Direct UPDATE markets SET creator_fees_earned (now handled by ledger trigger)
    
    -- Platform fee ledger entries
    INSERT INTO ledger_entries (user_id, account_type, account_ref_id, amount, entry_type, description)
    VALUES (NEW.user_id, 'market_pool', NEW.market_id, -v_platform_fee, 'trade_fee', 'Platform fee from trade');
    
    -- Get current platform balance
    SELECT COALESCE(SUM(amount), 0) INTO v_current_platform_balance
    FROM platform_ledger;
    
    -- Record platform fee
    INSERT INTO platform_ledger (transaction_type, amount, balance_after, reference_id, description)
    VALUES ('trade_fee', v_platform_fee, v_current_platform_balance + v_platform_fee, NEW.id, 'Platform fee from trade');
    
    RETURN NEW;
END;
$function$
"
"public","track_trade_fees_to_table","CREATE OR REPLACE FUNCTION public.track_trade_fees_to_table()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_market_creator_id UUID;
    v_total_fee NUMERIC;
    v_creator_fee NUMERIC;
    v_platform_fee NUMERIC;
    v_original_amount NUMERIC;
BEGIN
    -- Only process buy and sell transactions
    IF NEW.type NOT IN ('buy', 'sell') THEN
        RETURN NEW;
    END IF;
    
    -- Get the market creator
    SELECT creator_id INTO v_market_creator_id
    FROM markets
    WHERE id = NEW.market_id;
    
    IF v_market_creator_id IS NULL THEN
        RAISE WARNING '[Fees] Market creator not found for market: %', NEW.market_id;
        RETURN NEW;
    END IF;
    
    -- Calculate fees
    v_original_amount := ABS(NEW.amount);
    v_total_fee := v_original_amount * 0.01;  -- 1% total fee
    v_creator_fee := v_total_fee * 0.5;       -- 0.5% to creator
    v_platform_fee := v_total_fee * 0.5;      -- 0.5% to platform
    
    -- Creator fee
    INSERT INTO fees (
        user_id,
        market_id,
        transaction_type,
        original_amount,
        fee_amount,
        fee_percentage,
        net_amount,
        fee_type,
        paid_out,
        created_at
    ) VALUES (
        v_market_creator_id,
        NEW.market_id,
        NEW.type,
        v_original_amount,
        v_creator_fee,
        0.005,
        v_creator_fee,
        'creator',
        false,
        NOW()
    );
    
    -- Platform fee
    INSERT INTO fees (
        user_id,
        market_id,
        transaction_type,
        original_amount,
        fee_amount,
        fee_percentage,
        net_amount,
        fee_type,
        paid_out,
        created_at
    ) VALUES (
        NEW.user_id,
        NEW.market_id,
        NEW.type,
        v_original_amount,
        v_platform_fee,
        0.005,
        v_platform_fee,
        'site',
        false,
        NOW()
    );
    
    -- Update aggregated creator fees
    UPDATE markets
    SET creator_fees_earned = COALESCE(creator_fees_earned, 0) + v_creator_fee,
        updated_at = NOW()
    WHERE id = NEW.market_id;
    
    RETURN NEW;
END;
$function$
"
"public","track_trade_to_ledger","CREATE OR REPLACE FUNCTION public.track_trade_to_ledger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_user_account_id UUID;
    v_pool_account_id UUID;
    v_creator_fees_account_id UUID;
    v_platform_account_id UUID;
    v_amount_cents BIGINT;
    v_total_fee_cents BIGINT;
    v_platform_fee_cents BIGINT;
    v_creator_fee_cents BIGINT;
    v_amount_to_pool_cents BIGINT;
    -- New variables for sell gross calculation
    v_gross_amount_cents BIGINT;
    v_net_amount_cents BIGINT;
BEGIN
    -- Only process buy and sell transactions
    IF NEW.type NOT IN ('buy', 'sell') THEN
        RETURN NEW;
    END IF;
    
    -- Convert dollars to cents by multiplying by 100
    v_amount_cents := (ABS(NEW.amount) * 100)::BIGINT;
    
    RAISE NOTICE '[Ledger] Processing % trade: amount=$%, user=%, market=%',
        NEW.type, v_amount_cents / 100.0, NEW.user_id, NEW.market_id;
    
    -- Get or create accounts
    v_user_account_id := get_or_create_account(NEW.user_id, 'user');
    v_pool_account_id := get_or_create_account(NEW.market_id, 'market_pool');
    v_creator_fees_account_id := get_or_create_account(NEW.market_id, 'market_creator_fees');
    v_platform_account_id := get_or_create_account(
        '00000000-0000-0000-0000-000000000000'::UUID,
        'platform'
    );
    
    IF NEW.type = 'buy' THEN
        -- BUY TRADE (unchanged)
        -- For BUY: amount in transactions is GROSS (user pays full amount)
        -- Calculate fees: 1% total, split 50/50 between platform and creator
        v_total_fee_cents := (v_amount_cents * 0.01)::BIGINT;
        v_platform_fee_cents := (v_total_fee_cents * 0.5)::BIGINT;
        v_creator_fee_cents := v_total_fee_cents - v_platform_fee_cents;
        v_amount_to_pool_cents := v_amount_cents - v_total_fee_cents;
        
        -- 1. Debit user for full amount
        PERFORM create_ledger_entry(
            v_user_account_id,
            'debit',
            v_amount_cents,
            'trade',
            NEW.id,
            NEW.user_id,
            NEW.market_id,
            FORMAT('Buy trade - Amount: $%s', v_amount_cents / 100.0),
            jsonb_build_object('trade_type', 'buy', 'side', NEW.side)
        );
        
        -- 2. Credit pool for amount minus fees (99%)
        PERFORM create_ledger_entry(
            v_pool_account_id,
            'credit',
            v_amount_to_pool_cents,
            'trade',
            NEW.id,
            NEW.user_id,
            NEW.market_id,
            FORMAT('Pool receives buy payment (minus fees): $%s', v_amount_to_pool_cents / 100.0),
            jsonb_build_object('trade_type', 'buy', 'side', NEW.side)
        );
        
        -- 3. Credit platform fee account (0.5%)
        PERFORM create_ledger_entry(
            v_platform_account_id,
            'credit',
            v_platform_fee_cents,
            'trade_fee',
            NEW.id,
            NEW.user_id,
            NEW.market_id,
            FORMAT('Platform fee from buy trade: $%s', v_platform_fee_cents / 100.0),
            jsonb_build_object('trade_type', 'buy', 'fee_type', 'platform')
        );
        
        -- 4. Credit creator fees account (0.5%)
        PERFORM create_ledger_entry(
            v_creator_fees_account_id,
            'credit',
            v_creator_fee_cents,
            'trade_fee',
            NEW.id,
            NEW.user_id,
            NEW.market_id,
            FORMAT('Creator fee from buy trade: $%s', v_creator_fee_cents / 100.0),
            jsonb_build_object('trade_type', 'buy', 'fee_type', 'creator')
        );
        
        RAISE NOTICE '[Ledger] Buy trade tracked: user paid $%, pool got $%, fees: platform=$% creator=$%',
            v_amount_cents / 100.0, v_amount_to_pool_cents / 100.0,
            v_platform_fee_cents / 100.0, v_creator_fee_cents / 100.0;
            
    ELSIF NEW.type = 'sell' THEN
        -- SELL TRADE - Fixed calculation
        -- For SELL: amount in transactions is NET (user already received after fee deduction)
        -- So we need to calculate GROSS = NET / 0.99 for pool debit and fees
        
        v_net_amount_cents := v_amount_cents;  -- This is what user receives (already net)
        v_gross_amount_cents := (v_net_amount_cents / 0.99)::BIGINT;  -- Calculate gross from pool
        
        -- Calculate fees from GROSS amount
        v_total_fee_cents := v_gross_amount_cents - v_net_amount_cents;  -- Difference is total fee
        v_platform_fee_cents := (v_total_fee_cents * 0.5)::BIGINT;
        v_creator_fee_cents := v_total_fee_cents - v_platform_fee_cents;
        
        -- 1. Credit user for NET amount (what they actually receive, same as transactions.amount)
        PERFORM create_ledger_entry(
            v_user_account_id,
            'credit',
            v_net_amount_cents,
            'trade',
            NEW.id,
            NEW.user_id,
            NEW.market_id,
            FORMAT('Sell trade proceeds (net after fees): $%s', v_net_amount_cents / 100.0),
            jsonb_build_object('trade_type', 'sell', 'side', NEW.side)
        );
        
        -- 2. Debit pool for GROSS amount (net + fees)
        PERFORM create_ledger_entry(
            v_pool_account_id,
            'debit',
            v_gross_amount_cents,
            'trade',
            NEW.id,
            NEW.user_id,
            NEW.market_id,
            FORMAT('Pool pays for sell trade (gross): $%s', v_gross_amount_cents / 100.0),
            jsonb_build_object('trade_type', 'sell', 'side', NEW.side)
        );
        
        -- 3. Credit platform fee account (0.5% of gross)
        PERFORM create_ledger_entry(
            v_platform_account_id,
            'credit',
            v_platform_fee_cents,
            'trade_fee',
            NEW.id,
            NEW.user_id,
            NEW.market_id,
            FORMAT('Platform fee from sell trade: $%s', v_platform_fee_cents / 100.0),
            jsonb_build_object('trade_type', 'sell', 'fee_type', 'platform')
        );
        
        -- 4. Credit creator fees account (0.5% of gross)
        PERFORM create_ledger_entry(
            v_creator_fees_account_id,
            'credit',
            v_creator_fee_cents,
            'trade_fee',
            NEW.id,
            NEW.user_id,
            NEW.market_id,
            FORMAT('Creator fee from sell trade: $%s', v_creator_fee_cents / 100.0),
            jsonb_build_object('trade_type', 'sell', 'fee_type', 'creator')
        );
        
        RAISE NOTICE '[Ledger] Sell trade tracked: user got $% (net), pool paid $% (gross), fees: platform=$% creator=$%',
            v_net_amount_cents / 100.0, v_gross_amount_cents / 100.0,
            v_platform_fee_cents / 100.0, v_creator_fee_cents / 100.0;
    END IF;
    
    RETURN NEW;
EXCEPTION
    WHEN OTHERS THEN
        RAISE WARNING '[Ledger] Error tracking trade: %', SQLERRM;
        RETURN NEW;
END;
$function$
"
"public","track_transaction_fees","CREATE OR REPLACE FUNCTION public.track_transaction_fees()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_market RECORD;
    v_fee_amount NUMERIC;
    v_creator_fee NUMERIC;
    v_platform_fee NUMERIC;
    v_current_platform_balance NUMERIC;
BEGIN
    -- Only process buy/sell transactions
    IF NEW.type NOT IN ('buy', 'sell') THEN
        RETURN NEW;
    END IF;
    
    -- Get market info
    SELECT * INTO v_market FROM markets WHERE id = NEW.market_id;
    IF NOT FOUND THEN
        RETURN NEW;
    END IF;
    
    -- Calculate fees (2% total, split 50/50)
    v_fee_amount := ABS(NEW.amount) * 0.02;
    v_creator_fee := v_fee_amount * 0.5;
    v_platform_fee := v_fee_amount * 0.5;
    
    -- Create ledger entries for creator fee
    -- Debit from trading fees pool
    INSERT INTO ledger_entries (user_id, account_type, account_ref_id, amount, entry_type, description)
    VALUES (NEW.user_id, 'trading_fees', NEW.market_id, -v_creator_fee, 'creator_fee', 'Creator fee allocation');
    
    -- Credit to creator fees (this triggers the column update via ledger trigger)
    INSERT INTO ledger_entries (user_id, account_type, account_ref_id, amount, entry_type, description)
    VALUES (v_market.creator_id, 'creator_fees', NEW.market_id, v_creator_fee, 'creator_fee', 'Creator fee earned');
    
    -- Removed: Direct UPDATE markets SET creator_fees_earned (now handled by ledger trigger)
    
    -- Get current platform balance
    SELECT COALESCE(SUM(amount), 0) INTO v_current_platform_balance
    FROM platform_ledger;
    
    -- Record platform fee in platform_ledger
    INSERT INTO platform_ledger (transaction_type, amount, balance_after, reference_id, description)
    VALUES ('trade_fee', v_platform_fee, v_current_platform_balance + v_platform_fee, NEW.id, 
            'Platform fee from ' || NEW.type || ' transaction');
    
    RETURN NEW;
END;
$function$
"
"public","track_user_shares","CREATE OR REPLACE FUNCTION public.track_user_shares()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_prev_qy NUMERIC := 0;
  v_prev_qn NUMERIC := 0;
  v_new_qy NUMERIC := 0;
  v_new_qn NUMERIC := 0;
  v_shares NUMERIC := 0;
BEGIN
  IF NEW.type NOT IN ('buy', 'sell', 'settlement_payout', 'settlement_win', 'settlement_loss')
     OR NEW.market_id IS NULL OR NEW.user_id IS NULL THEN
    RETURN NEW;
  END IF;

  v_shares := COALESCE(NEW.shares, 0);

  SELECT user_qy, user_qn
    INTO v_prev_qy, v_prev_qn
  FROM transactions
  WHERE user_id = NEW.user_id
    AND market_id = NEW.market_id
    AND id != NEW.id
    AND created_at <= NEW.created_at
  ORDER BY created_at DESC, id DESC
  LIMIT 1;

  v_prev_qy := COALESCE(v_prev_qy, 0);
  v_prev_qn := COALESCE(v_prev_qn, 0);

  NEW.user_qy_credit := 0;
  NEW.user_qy_debit  := 0;
  NEW.user_qn_credit := 0;
  NEW.user_qn_debit  := 0;

  IF NEW.type = 'buy' THEN
    IF NEW.side = 'yes' THEN
      NEW.user_qy_credit := v_shares;  v_new_qy := v_prev_qy + v_shares; v_new_qn := v_prev_qn;
    ELSE
      NEW.user_qn_credit := v_shares;  v_new_qn := v_prev_qn + v_shares; v_new_qy := v_prev_qy;
    END IF;

  ELSIF NEW.type = 'sell' THEN
    IF NEW.side = 'yes' THEN
      NEW.user_qy_debit := v_shares;   v_new_qy := v_prev_qy - v_shares; v_new_qn := v_prev_qn;
    ELSE
      NEW.user_qn_debit := v_shares;   v_new_qn := v_prev_qn - v_shares; v_new_qy := v_prev_qy;
    END IF;

  ELSE -- Settlement payout or win/loss
    SELECT
      COALESCE(SUM(CASE WHEN side='yes' THEN shares ELSE 0 END),0),
      COALESCE(SUM(CASE WHEN side='no' THEN shares ELSE 0 END),0)
    INTO v_prev_qy, v_prev_qn
    FROM positions
    WHERE user_id = NEW.user_id AND market_id = NEW.market_id;

    NEW.user_qy_debit := v_prev_qy;
    NEW.user_qn_debit := v_prev_qn;
    v_new_qy := 0;
    v_new_qn := 0;
  END IF;

  NEW.user_qy := GREATEST(v_new_qy, 0);
  NEW.user_qn := GREATEST(v_new_qn, 0);

  RETURN NEW;
END;
$function$
"
"public","update_balance_snapshot","CREATE OR REPLACE FUNCTION public.update_balance_snapshot()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_current_balance_cents BIGINT;
BEGIN
    IF NEW.account_id IS NOT NULL THEN
        
        SELECT COALESCE(SUM(
            CASE 
                WHEN entry_side = 'debit' THEN amount_cents
                WHEN entry_side = 'credit' THEN -amount_cents
                ELSE 0
            END
        ), 0)
        INTO v_current_balance_cents
        FROM ledger_entries
        WHERE account_id = NEW.account_id;

        INSERT INTO ledger_balance_snapshots (
            account_id,
            balance_cents,
            last_ledger_entry_id,
            updated_at
        )
        VALUES (
            NEW.account_id,
            v_current_balance_cents,
            NEW.id,
            NOW()
        )
        ON CONFLICT (account_id)
        DO UPDATE SET
            balance_cents         = EXCLUDED.balance_cents,
            last_ledger_entry_id  = EXCLUDED.last_ledger_entry_id,
            updated_at            = NOW();
    END IF;

    RETURN NEW;
END;
$function$
"
"public","update_creator_fees_from_ledger","CREATE OR REPLACE FUNCTION public.update_creator_fees_from_ledger()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Only update on credits (positive income) to creator_fees accounts
  -- Use NEW.credit > 0 instead of NEW.amount > 0
  -- Use account_ref_id instead of market_id
  IF NEW.account_type = 'creator_fees' AND NEW.credit > 0 THEN
    UPDATE markets 
    SET creator_fees_earned = creator_fees_earned + NEW.credit
    WHERE id = NEW.account_ref_id;
  END IF;
  
  RETURN NEW;
END;
$function$
"
"public","update_market_threshold_check","CREATE OR REPLACE FUNCTION public.update_market_threshold_check()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_current_yes_prob NUMERIC;
    v_threshold NUMERIC := 99.0;  -- 99% threshold for YES
    v_hours_required NUMERIC := 3.0;  -- 3 hours sustained
    v_hours_elapsed NUMERIC;
BEGIN
    -- Calculate current YES probability: e^(qy/b) / (e^(qy/b) + e^(qn/b))
    v_current_yes_prob := ROUND(
        (EXP(NEW.qy / NEW.b) / (EXP(NEW.qy / NEW.b) + EXP(NEW.qn / NEW.b))) * 100, 
        2
    );
    
    -- Update the stored probability for display
    NEW.twap_yes_probability := v_current_yes_prob;
    NEW.twap_last_updated := NOW();
    
    -- Check if above 99% threshold
    IF v_current_yes_prob >= v_threshold THEN
        -- If just crossed above 99%, start the clock
        IF OLD.twap_above_threshold_since IS NULL THEN
            NEW.twap_above_threshold_since := NOW();
        ELSE
            -- Check if we've been above 99% for 3+ hours
            v_hours_elapsed := EXTRACT(EPOCH FROM (NOW() - OLD.twap_above_threshold_since)) / 3600.0;
            
            IF v_hours_elapsed >= v_hours_required THEN
                NEW.early_settlement_unlocked := TRUE;
            END IF;
        END IF;
    ELSE
        -- Dropped below 99%, reset the clock
        NEW.twap_above_threshold_since := NULL;
        -- Don't reset early_settlement_unlocked (one-way flag)
    END IF;
    
    RETURN NEW;
END;
$function$
"
"public","update_market_twap","CREATE OR REPLACE FUNCTION public.update_market_twap()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_current_prob NUMERIC;
    v_old_twap NUMERIC;
    v_new_twap NUMERIC;
    v_time_since_last NUMERIC;
    v_decay_factor NUMERIC;
    v_threshold_high NUMERIC := 99.0;  -- 99% threshold
    v_threshold_low NUMERIC := 1.0;    -- 1% threshold
    v_hours_required NUMERIC := 4.0;   -- 4 hours sustained
    v_is_above_threshold BOOLEAN;
BEGIN
    -- Calculate current probability from updated market state
    v_current_prob := calculate_yes_probability(NEW.qy, NEW.qn, NEW.b);
    
    -- Get old TWAP (or use current prob if no history)
    v_old_twap := COALESCE(OLD.twap_yes_probability, v_current_prob);
    
    -- Calculate time since last update in hours
    IF OLD.twap_last_updated IS NOT NULL THEN
        v_time_since_last := EXTRACT(EPOCH FROM (NOW() - OLD.twap_last_updated)) / 3600.0;
    ELSE
        v_time_since_last := 0;
    END IF;
    
    -- Exponential Moving Average with time-based decay
    -- Decay factor: shorter time = more weight to new value, longer time = blend toward new
    -- Using alpha = 1 - e^(-time/2) for smooth decay with 2-hour half-life
    IF v_time_since_last > 0 THEN
        v_decay_factor := 1 - EXP(-v_time_since_last / 2.0);
        v_decay_factor := GREATEST(0.1, LEAST(0.9, v_decay_factor)); -- Clamp between 0.1 and 0.9
    ELSE
        v_decay_factor := 0.3; -- Default blend for rapid trades
    END IF;
    
    -- Calculate new TWAP as weighted average
    v_new_twap := ROUND((v_decay_factor * v_current_prob) + ((1 - v_decay_factor) * v_old_twap), 2);
    
    -- Check if TWAP is above threshold (either direction)
    v_is_above_threshold := (v_new_twap >= v_threshold_high OR v_new_twap <= v_threshold_low);
    
    -- Update the market record
    NEW.twap_yes_probability := v_new_twap;
    NEW.twap_last_updated := NOW();
    
    -- Track threshold crossing
    IF v_is_above_threshold THEN
        -- If just crossed threshold, record the timestamp
        IF OLD.twap_above_threshold_since IS NULL THEN
            NEW.twap_above_threshold_since := NOW();
        ELSE
            -- Check if we've been above threshold long enough
            IF EXTRACT(EPOCH FROM (NOW() - OLD.twap_above_threshold_since)) / 3600.0 >= v_hours_required THEN
                NEW.early_settlement_unlocked := TRUE;
            END IF;
        END IF;
    ELSE
        -- Dropped below threshold, reset tracker
        NEW.twap_above_threshold_since := NULL;
        -- Don't reset early_settlement_unlocked once it's true (one-way flag)
    END IF;
    
    RETURN NEW;
END;
$function$
"
"public","update_uma_proposals_updated_at","CREATE OR REPLACE FUNCTION public.update_uma_proposals_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
"
"public","uuid_generate_v1","CREATE OR REPLACE FUNCTION public.uuid_generate_v1()
 RETURNS uuid
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_generate_v1$function$
"
"public","uuid_generate_v1mc","CREATE OR REPLACE FUNCTION public.uuid_generate_v1mc()
 RETURNS uuid
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_generate_v1mc$function$
"
"public","uuid_generate_v3","CREATE OR REPLACE FUNCTION public.uuid_generate_v3(namespace uuid, name text)
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_generate_v3$function$
"
"public","uuid_generate_v4","CREATE OR REPLACE FUNCTION public.uuid_generate_v4()
 RETURNS uuid
 LANGUAGE c
 PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_generate_v4$function$
"
"public","uuid_generate_v5","CREATE OR REPLACE FUNCTION public.uuid_generate_v5(namespace uuid, name text)
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_generate_v5$function$
"
"public","uuid_nil","CREATE OR REPLACE FUNCTION public.uuid_nil()
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_nil$function$
"
"public","uuid_ns_dns","CREATE OR REPLACE FUNCTION public.uuid_ns_dns()
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_ns_dns$function$
"
"public","uuid_ns_oid","CREATE OR REPLACE FUNCTION public.uuid_ns_oid()
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_ns_oid$function$
"
"public","uuid_ns_url","CREATE OR REPLACE FUNCTION public.uuid_ns_url()
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_ns_url$function$
"
"public","uuid_ns_x500","CREATE OR REPLACE FUNCTION public.uuid_ns_x500()
 RETURNS uuid
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/uuid-ossp', $function$uuid_ns_x500$function$
"
